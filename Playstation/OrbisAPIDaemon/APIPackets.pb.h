// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: APIPackets.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_APIPackets_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_APIPackets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_APIPackets_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_APIPackets_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[37]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_APIPackets_2eproto;
class Acc;
struct AccDefaultTypeInternal;
extern AccDefaultTypeInternal _Acc_default_instance_;
class AppInfoListPacket;
struct AppInfoListPacketDefaultTypeInternal;
extern AppInfoListPacketDefaultTypeInternal _AppInfoListPacket_default_instance_;
class AppInfoPacket;
struct AppInfoPacketDefaultTypeInternal;
extern AppInfoPacketDefaultTypeInternal _AppInfoPacket_default_instance_;
class AppPacket;
struct AppPacketDefaultTypeInternal;
extern AppPacketDefaultTypeInternal _AppPacket_default_instance_;
class BreakpointListPacket;
struct BreakpointListPacketDefaultTypeInternal;
extern BreakpointListPacketDefaultTypeInternal _BreakpointListPacket_default_instance_;
class BreakpointPacket;
struct BreakpointPacketDefaultTypeInternal;
extern BreakpointPacketDefaultTypeInternal _BreakpointPacket_default_instance_;
class CurrentBigApp;
struct CurrentBigAppDefaultTypeInternal;
extern CurrentBigAppDefaultTypeInternal _CurrentBigApp_default_instance_;
class DebuggerInterruptPacket;
struct DebuggerInterruptPacketDefaultTypeInternal;
extern DebuggerInterruptPacketDefaultTypeInternal _DebuggerInterruptPacket_default_instance_;
class Envxmm;
struct EnvxmmDefaultTypeInternal;
extern EnvxmmDefaultTypeInternal _Envxmm_default_instance_;
class FilePacket;
struct FilePacketDefaultTypeInternal;
extern FilePacketDefaultTypeInternal _FilePacket_default_instance_;
class Fpregs;
struct FpregsDefaultTypeInternal;
extern FpregsDefaultTypeInternal _Fpregs_default_instance_;
class InitialPacket;
struct InitialPacketDefaultTypeInternal;
extern InitialPacketDefaultTypeInternal _InitialPacket_default_instance_;
class LibraryInfoPacket;
struct LibraryInfoPacketDefaultTypeInternal;
extern LibraryInfoPacketDefaultTypeInternal _LibraryInfoPacket_default_instance_;
class LibraryListPacket;
struct LibraryListPacketDefaultTypeInternal;
extern LibraryListPacketDefaultTypeInternal _LibraryListPacket_default_instance_;
class MemoryInfo;
struct MemoryInfoDefaultTypeInternal;
extern MemoryInfoDefaultTypeInternal _MemoryInfo_default_instance_;
class NamedObjectListPacket;
struct NamedObjectListPacketDefaultTypeInternal;
extern NamedObjectListPacketDefaultTypeInternal _NamedObjectListPacket_default_instance_;
class NamedObjectPacket;
struct NamedObjectPacketDefaultTypeInternal;
extern NamedObjectPacketDefaultTypeInternal _NamedObjectPacket_default_instance_;
class PagePacket;
struct PagePacketDefaultTypeInternal;
extern PagePacketDefaultTypeInternal _PagePacket_default_instance_;
class PagesListPacket;
struct PagesListPacketDefaultTypeInternal;
extern PagesListPacketDefaultTypeInternal _PagesListPacket_default_instance_;
class ProcListPacket;
struct ProcListPacketDefaultTypeInternal;
extern ProcListPacketDefaultTypeInternal _ProcListPacket_default_instance_;
class ProcPacket;
struct ProcPacketDefaultTypeInternal;
extern ProcPacketDefaultTypeInternal _ProcPacket_default_instance_;
class RWPacket;
struct RWPacketDefaultTypeInternal;
extern RWPacketDefaultTypeInternal _RWPacket_default_instance_;
class RegistersPacket;
struct RegistersPacketDefaultTypeInternal;
extern RegistersPacketDefaultTypeInternal _RegistersPacket_default_instance_;
class ResultState;
struct ResultStateDefaultTypeInternal;
extern ResultStateDefaultTypeInternal _ResultState_default_instance_;
class SPRXPacket;
struct SPRXPacketDefaultTypeInternal;
extern SPRXPacketDefaultTypeInternal _SPRXPacket_default_instance_;
class SavefpuXstate;
struct SavefpuXstateDefaultTypeInternal;
extern SavefpuXstateDefaultTypeInternal _SavefpuXstate_default_instance_;
class SetProcessProtPacket;
struct SetProcessProtPacketDefaultTypeInternal;
extern SetProcessProtPacketDefaultTypeInternal _SetProcessProtPacket_default_instance_;
class TargetInfoPacket;
struct TargetInfoPacketDefaultTypeInternal;
extern TargetInfoPacketDefaultTypeInternal _TargetInfoPacket_default_instance_;
class TargetNotifyPacket;
struct TargetNotifyPacketDefaultTypeInternal;
extern TargetNotifyPacketDefaultTypeInternal _TargetNotifyPacket_default_instance_;
class TargetSettingsPacket;
struct TargetSettingsPacketDefaultTypeInternal;
extern TargetSettingsPacketDefaultTypeInternal _TargetSettingsPacket_default_instance_;
class ThreadInfoPacket;
struct ThreadInfoPacketDefaultTypeInternal;
extern ThreadInfoPacketDefaultTypeInternal _ThreadInfoPacket_default_instance_;
class ThreadListPacket;
struct ThreadListPacketDefaultTypeInternal;
extern ThreadListPacketDefaultTypeInternal _ThreadListPacket_default_instance_;
class WatchpointListPacket;
struct WatchpointListPacketDefaultTypeInternal;
extern WatchpointListPacketDefaultTypeInternal _WatchpointListPacket_default_instance_;
class WatchpointPacket;
struct WatchpointPacketDefaultTypeInternal;
extern WatchpointPacketDefaultTypeInternal _WatchpointPacket_default_instance_;
class Xmmacc;
struct XmmaccDefaultTypeInternal;
extern XmmaccDefaultTypeInternal _Xmmacc_default_instance_;
class XstateHdr;
struct XstateHdrDefaultTypeInternal;
extern XstateHdrDefaultTypeInternal _XstateHdr_default_instance_;
class Ymmacc;
struct YmmaccDefaultTypeInternal;
extern YmmaccDefaultTypeInternal _Ymmacc_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Acc* Arena::CreateMaybeMessage<::Acc>(Arena*);
template<> ::AppInfoListPacket* Arena::CreateMaybeMessage<::AppInfoListPacket>(Arena*);
template<> ::AppInfoPacket* Arena::CreateMaybeMessage<::AppInfoPacket>(Arena*);
template<> ::AppPacket* Arena::CreateMaybeMessage<::AppPacket>(Arena*);
template<> ::BreakpointListPacket* Arena::CreateMaybeMessage<::BreakpointListPacket>(Arena*);
template<> ::BreakpointPacket* Arena::CreateMaybeMessage<::BreakpointPacket>(Arena*);
template<> ::CurrentBigApp* Arena::CreateMaybeMessage<::CurrentBigApp>(Arena*);
template<> ::DebuggerInterruptPacket* Arena::CreateMaybeMessage<::DebuggerInterruptPacket>(Arena*);
template<> ::Envxmm* Arena::CreateMaybeMessage<::Envxmm>(Arena*);
template<> ::FilePacket* Arena::CreateMaybeMessage<::FilePacket>(Arena*);
template<> ::Fpregs* Arena::CreateMaybeMessage<::Fpregs>(Arena*);
template<> ::InitialPacket* Arena::CreateMaybeMessage<::InitialPacket>(Arena*);
template<> ::LibraryInfoPacket* Arena::CreateMaybeMessage<::LibraryInfoPacket>(Arena*);
template<> ::LibraryListPacket* Arena::CreateMaybeMessage<::LibraryListPacket>(Arena*);
template<> ::MemoryInfo* Arena::CreateMaybeMessage<::MemoryInfo>(Arena*);
template<> ::NamedObjectListPacket* Arena::CreateMaybeMessage<::NamedObjectListPacket>(Arena*);
template<> ::NamedObjectPacket* Arena::CreateMaybeMessage<::NamedObjectPacket>(Arena*);
template<> ::PagePacket* Arena::CreateMaybeMessage<::PagePacket>(Arena*);
template<> ::PagesListPacket* Arena::CreateMaybeMessage<::PagesListPacket>(Arena*);
template<> ::ProcListPacket* Arena::CreateMaybeMessage<::ProcListPacket>(Arena*);
template<> ::ProcPacket* Arena::CreateMaybeMessage<::ProcPacket>(Arena*);
template<> ::RWPacket* Arena::CreateMaybeMessage<::RWPacket>(Arena*);
template<> ::RegistersPacket* Arena::CreateMaybeMessage<::RegistersPacket>(Arena*);
template<> ::ResultState* Arena::CreateMaybeMessage<::ResultState>(Arena*);
template<> ::SPRXPacket* Arena::CreateMaybeMessage<::SPRXPacket>(Arena*);
template<> ::SavefpuXstate* Arena::CreateMaybeMessage<::SavefpuXstate>(Arena*);
template<> ::SetProcessProtPacket* Arena::CreateMaybeMessage<::SetProcessProtPacket>(Arena*);
template<> ::TargetInfoPacket* Arena::CreateMaybeMessage<::TargetInfoPacket>(Arena*);
template<> ::TargetNotifyPacket* Arena::CreateMaybeMessage<::TargetNotifyPacket>(Arena*);
template<> ::TargetSettingsPacket* Arena::CreateMaybeMessage<::TargetSettingsPacket>(Arena*);
template<> ::ThreadInfoPacket* Arena::CreateMaybeMessage<::ThreadInfoPacket>(Arena*);
template<> ::ThreadListPacket* Arena::CreateMaybeMessage<::ThreadListPacket>(Arena*);
template<> ::WatchpointListPacket* Arena::CreateMaybeMessage<::WatchpointListPacket>(Arena*);
template<> ::WatchpointPacket* Arena::CreateMaybeMessage<::WatchpointPacket>(Arena*);
template<> ::Xmmacc* Arena::CreateMaybeMessage<::Xmmacc>(Arena*);
template<> ::XstateHdr* Arena::CreateMaybeMessage<::XstateHdr>(Arena*);
template<> ::Ymmacc* Arena::CreateMaybeMessage<::Ymmacc>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum APICommand : int {
  API_APPS_CHECK_VER = 0,
  API_APPS_GET_DB = 1,
  API_APPS_GET_INFO_STR = 2,
  API_APPS_STATUS = 3,
  API_APPS_START = 4,
  API_APPS_STOP = 5,
  API_APPS_SUSPEND = 6,
  API_APPS_RESUME = 7,
  API_APPS_DELETE = 8,
  API_APPS_SET_VISIBILITY = 9,
  API_APPS_GET_VISIBILITY = 10,
  API_DBG_ATTACH = 11,
  API_DBG_DETACH = 12,
  API_DBG_GET_CURRENT = 13,
  API_DBG_READ = 14,
  API_DBG_WRITE = 15,
  API_DBG_KILL = 16,
  API_DBG_BREAK = 17,
  API_DBG_RESUME = 18,
  API_DBG_SIGNAL = 19,
  API_DBG_STEP = 20,
  API_DBG_STEP_OVER = 21,
  API_DBG_STEP_OUT = 22,
  API_DBG_GET_CALLSTACK = 23,
  API_DBG_GET_REG = 24,
  API_DBG_SET_REG = 25,
  API_DBG_GET_FREG = 26,
  API_DBG_SET_FREG = 27,
  API_DBG_GET_DBGREG = 28,
  API_DBG_SET_DBGREG = 29,
  API_DBG_LOAD_LIBRARY = 30,
  API_DBG_UNLOAD_LIBRARY = 31,
  API_DBG_RELOAD_LIBRARY = 32,
  API_DBG_LIBRARY_LIST = 33,
  API_DBG_THREAD_LIST = 34,
  API_DBG_THREAD_STOP = 35,
  API_DBG_THREAD_RESUME = 36,
  API_DBG_BREAKPOINT_GETFREE = 37,
  API_DBG_BREAKPOINT_SET = 38,
  API_DBG_BREAKPOINT_UPDATE = 39,
  API_DBG_BREAKPOINT_REMOVE = 40,
  API_DBG_BREAKPOINT_GETINFO = 41,
  API_DBG_BREAKPOINT_LIST = 42,
  API_DBG_WATCHPOINT_SET = 43,
  API_DBG_WATCHPOINT_UPDATE = 44,
  API_DBG_WATCHPOINT_REMOVE = 45,
  API_DBG_WATCHPOINT_GETINFO = 46,
  API_DBG_WATCHPOINT_LIST = 47,
  API_KERN_BASE = 48,
  API_KERN_READ = 49,
  API_KERN_WRITE = 50,
  API_TARGET_INFO = 51,
  API_TARGET_RESTMODE = 52,
  API_TARGET_SHUTDOWN = 53,
  API_TARGET_REBOOT = 54,
  API_TARGET_NOTIFY = 55,
  API_TARGET_BUZZER = 56,
  API_TARGET_SET_LED = 57,
  API_TARGET_SET_SETTINGS = 58,
  API_TARGET_GET_PROC_LIST = 59,
  API_TARGET_SEND_FILE = 60,
  API_TARGET_RECIEVE_FILE = 61,
  API_TARGET_DELETE_FILE = 62,
  API_EXT_GET_PAGES = 63,
  API_EXT_GET_THREAD_INFO = 64,
  API_EXT_GET_NAMED_OBJECTS = 65,
  API_EXT_SET_PROC_PROT = 66,
  APICommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  APICommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool APICommand_IsValid(int value);
constexpr APICommand APICommand_MIN = API_APPS_CHECK_VER;
constexpr APICommand APICommand_MAX = API_EXT_SET_PROC_PROT;
constexpr int APICommand_ARRAYSIZE = APICommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* APICommand_descriptor();
template<typename T>
inline const std::string& APICommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, APICommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function APICommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    APICommand_descriptor(), enum_t_value);
}
inline bool APICommand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, APICommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<APICommand>(
    APICommand_descriptor(), name, value);
}
enum AppState : int {
  STATE_NOT_RUNNING = 0,
  STATE_RUNNING = 1,
  STATE_SUSPENDED = 2,
  AppState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AppState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AppState_IsValid(int value);
constexpr AppState AppState_MIN = STATE_NOT_RUNNING;
constexpr AppState AppState_MAX = STATE_SUSPENDED;
constexpr int AppState_ARRAYSIZE = AppState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppState_descriptor();
template<typename T>
inline const std::string& AppState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppState_descriptor(), enum_t_value);
}
inline bool AppState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppState>(
    AppState_descriptor(), name, value);
}
// ===================================================================

class InitialPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InitialPacket) */ {
 public:
  inline InitialPacket() : InitialPacket(nullptr) {}
  ~InitialPacket() override;
  explicit constexpr InitialPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitialPacket(const InitialPacket& from);
  InitialPacket(InitialPacket&& from) noexcept
    : InitialPacket() {
    *this = ::std::move(from);
  }

  inline InitialPacket& operator=(const InitialPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialPacket& operator=(InitialPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitialPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitialPacket* internal_default_instance() {
    return reinterpret_cast<const InitialPacket*>(
               &_InitialPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InitialPacket& a, InitialPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(InitialPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitialPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitialPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitialPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitialPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitialPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitialPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InitialPacket";
  }
  protected:
  explicit InitialPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketVersionFieldNumber = 1,
    kCommandFieldNumber = 2,
  };
  // int32 PacketVersion = 1;
  void clear_packetversion();
  int32_t packetversion() const;
  void set_packetversion(int32_t value);
  private:
  int32_t _internal_packetversion() const;
  void _internal_set_packetversion(int32_t value);
  public:

  // int32 Command = 2;
  void clear_command();
  int32_t command() const;
  void set_command(int32_t value);
  private:
  int32_t _internal_command() const;
  void _internal_set_command(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:InitialPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t packetversion_;
  int32_t command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class ResultState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResultState) */ {
 public:
  inline ResultState() : ResultState(nullptr) {}
  ~ResultState() override;
  explicit constexpr ResultState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultState(const ResultState& from);
  ResultState(ResultState&& from) noexcept
    : ResultState() {
    *this = ::std::move(from);
  }

  inline ResultState& operator=(const ResultState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultState& operator=(ResultState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultState* internal_default_instance() {
    return reinterpret_cast<const ResultState*>(
               &_ResultState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResultState& a, ResultState& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResultState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResultState";
  }
  protected:
  explicit ResultState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSucceededFieldNumber = 1,
  };
  // string ErrorMessage = 2;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // bool Succeeded = 1;
  void clear_succeeded();
  bool succeeded() const;
  void set_succeeded(bool value);
  private:
  bool _internal_succeeded() const;
  void _internal_set_succeeded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ResultState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
  bool succeeded_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class AppInfoPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppInfoPacket) */ {
 public:
  inline AppInfoPacket() : AppInfoPacket(nullptr) {}
  ~AppInfoPacket() override;
  explicit constexpr AppInfoPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppInfoPacket(const AppInfoPacket& from);
  AppInfoPacket(AppInfoPacket&& from) noexcept
    : AppInfoPacket() {
    *this = ::std::move(from);
  }

  inline AppInfoPacket& operator=(const AppInfoPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppInfoPacket& operator=(AppInfoPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppInfoPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppInfoPacket* internal_default_instance() {
    return reinterpret_cast<const AppInfoPacket*>(
               &_AppInfoPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AppInfoPacket& a, AppInfoPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(AppInfoPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppInfoPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppInfoPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppInfoPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppInfoPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppInfoPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppInfoPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppInfoPacket";
  }
  protected:
  explicit AppInfoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleIdFieldNumber = 1,
    kContentIdFieldNumber = 2,
    kTitleNameFieldNumber = 3,
    kMetaDataPathFieldNumber = 4,
    kLastAccessTimeFieldNumber = 5,
    kCategoryFieldNumber = 9,
    kInstallDateFieldNumber = 11,
    kUICategoryFieldNumber = 12,
    kIsVisibleFieldNumber = 6,
    kSortPriorityFieldNumber = 7,
    kDispLocationFieldNumber = 8,
    kContentSizeFieldNumber = 10,
  };
  // string TitleId = 1;
  void clear_titleid();
  const std::string& titleid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titleid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titleid();
  PROTOBUF_NODISCARD std::string* release_titleid();
  void set_allocated_titleid(std::string* titleid);
  private:
  const std::string& _internal_titleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titleid(const std::string& value);
  std::string* _internal_mutable_titleid();
  public:

  // string ContentId = 2;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // string TitleName = 3;
  void clear_titlename();
  const std::string& titlename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titlename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titlename();
  PROTOBUF_NODISCARD std::string* release_titlename();
  void set_allocated_titlename(std::string* titlename);
  private:
  const std::string& _internal_titlename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titlename(const std::string& value);
  std::string* _internal_mutable_titlename();
  public:

  // string MetaDataPath = 4;
  void clear_metadatapath();
  const std::string& metadatapath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadatapath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadatapath();
  PROTOBUF_NODISCARD std::string* release_metadatapath();
  void set_allocated_metadatapath(std::string* metadatapath);
  private:
  const std::string& _internal_metadatapath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadatapath(const std::string& value);
  std::string* _internal_mutable_metadatapath();
  public:

  // string LastAccessTime = 5;
  void clear_lastaccesstime();
  const std::string& lastaccesstime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lastaccesstime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lastaccesstime();
  PROTOBUF_NODISCARD std::string* release_lastaccesstime();
  void set_allocated_lastaccesstime(std::string* lastaccesstime);
  private:
  const std::string& _internal_lastaccesstime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lastaccesstime(const std::string& value);
  std::string* _internal_mutable_lastaccesstime();
  public:

  // string Category = 9;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string InstallDate = 11;
  void clear_installdate();
  const std::string& installdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_installdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_installdate();
  PROTOBUF_NODISCARD std::string* release_installdate();
  void set_allocated_installdate(std::string* installdate);
  private:
  const std::string& _internal_installdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_installdate(const std::string& value);
  std::string* _internal_mutable_installdate();
  public:

  // string UICategory = 12;
  void clear_uicategory();
  const std::string& uicategory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uicategory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uicategory();
  PROTOBUF_NODISCARD std::string* release_uicategory();
  void set_allocated_uicategory(std::string* uicategory);
  private:
  const std::string& _internal_uicategory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uicategory(const std::string& value);
  std::string* _internal_mutable_uicategory();
  public:

  // bool IsVisible = 6;
  void clear_isvisible();
  bool isvisible() const;
  void set_isvisible(bool value);
  private:
  bool _internal_isvisible() const;
  void _internal_set_isvisible(bool value);
  public:

  // int32 SortPriority = 7;
  void clear_sortpriority();
  int32_t sortpriority() const;
  void set_sortpriority(int32_t value);
  private:
  int32_t _internal_sortpriority() const;
  void _internal_set_sortpriority(int32_t value);
  public:

  // int32 DispLocation = 8;
  void clear_displocation();
  int32_t displocation() const;
  void set_displocation(int32_t value);
  private:
  int32_t _internal_displocation() const;
  void _internal_set_displocation(int32_t value);
  public:

  // int32 ContentSize = 10;
  void clear_contentsize();
  int32_t contentsize() const;
  void set_contentsize(int32_t value);
  private:
  int32_t _internal_contentsize() const;
  void _internal_set_contentsize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AppInfoPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titleid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titlename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadatapath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lastaccesstime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr installdate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uicategory_;
  bool isvisible_;
  int32_t sortpriority_;
  int32_t displocation_;
  int32_t contentsize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class AppInfoListPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppInfoListPacket) */ {
 public:
  inline AppInfoListPacket() : AppInfoListPacket(nullptr) {}
  ~AppInfoListPacket() override;
  explicit constexpr AppInfoListPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppInfoListPacket(const AppInfoListPacket& from);
  AppInfoListPacket(AppInfoListPacket&& from) noexcept
    : AppInfoListPacket() {
    *this = ::std::move(from);
  }

  inline AppInfoListPacket& operator=(const AppInfoListPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppInfoListPacket& operator=(AppInfoListPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppInfoListPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppInfoListPacket* internal_default_instance() {
    return reinterpret_cast<const AppInfoListPacket*>(
               &_AppInfoListPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AppInfoListPacket& a, AppInfoListPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(AppInfoListPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppInfoListPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppInfoListPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppInfoListPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppInfoListPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppInfoListPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppInfoListPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppInfoListPacket";
  }
  protected:
  explicit AppInfoListPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppsFieldNumber = 1,
  };
  // repeated .AppInfoPacket Apps = 1;
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::AppInfoPacket* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AppInfoPacket >*
      mutable_apps();
  private:
  const ::AppInfoPacket& _internal_apps(int index) const;
  ::AppInfoPacket* _internal_add_apps();
  public:
  const ::AppInfoPacket& apps(int index) const;
  ::AppInfoPacket* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AppInfoPacket >&
      apps() const;

  // @@protoc_insertion_point(class_scope:AppInfoListPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AppInfoPacket > apps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class AppPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppPacket) */ {
 public:
  inline AppPacket() : AppPacket(nullptr) {}
  ~AppPacket() override;
  explicit constexpr AppPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppPacket(const AppPacket& from);
  AppPacket(AppPacket&& from) noexcept
    : AppPacket() {
    *this = ::std::move(from);
  }

  inline AppPacket& operator=(const AppPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppPacket& operator=(AppPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppPacket* internal_default_instance() {
    return reinterpret_cast<const AppPacket*>(
               &_AppPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AppPacket& a, AppPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(AppPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppPacket";
  }
  protected:
  explicit AppPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleIdFieldNumber = 1,
  };
  // string TitleId = 1;
  void clear_titleid();
  const std::string& titleid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titleid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titleid();
  PROTOBUF_NODISCARD std::string* release_titleid();
  void set_allocated_titleid(std::string* titleid);
  private:
  const std::string& _internal_titleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titleid(const std::string& value);
  std::string* _internal_mutable_titleid();
  public:

  // @@protoc_insertion_point(class_scope:AppPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titleid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class RWPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RWPacket) */ {
 public:
  inline RWPacket() : RWPacket(nullptr) {}
  ~RWPacket() override;
  explicit constexpr RWPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RWPacket(const RWPacket& from);
  RWPacket(RWPacket&& from) noexcept
    : RWPacket() {
    *this = ::std::move(from);
  }

  inline RWPacket& operator=(const RWPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline RWPacket& operator=(RWPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RWPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const RWPacket* internal_default_instance() {
    return reinterpret_cast<const RWPacket*>(
               &_RWPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RWPacket& a, RWPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(RWPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RWPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RWPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RWPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RWPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RWPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RWPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RWPacket";
  }
  protected:
  explicit RWPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kLengthFieldNumber = 2,
  };
  // uint64 Address = 1;
  void clear_address();
  uint64_t address() const;
  void set_address(uint64_t value);
  private:
  uint64_t _internal_address() const;
  void _internal_set_address(uint64_t value);
  public:

  // uint64 Length = 2;
  void clear_length();
  uint64_t length() const;
  void set_length(uint64_t value);
  private:
  uint64_t _internal_length() const;
  void _internal_set_length(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:RWPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t address_;
  uint64_t length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class SPRXPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SPRXPacket) */ {
 public:
  inline SPRXPacket() : SPRXPacket(nullptr) {}
  ~SPRXPacket() override;
  explicit constexpr SPRXPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPRXPacket(const SPRXPacket& from);
  SPRXPacket(SPRXPacket&& from) noexcept
    : SPRXPacket() {
    *this = ::std::move(from);
  }

  inline SPRXPacket& operator=(const SPRXPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPRXPacket& operator=(SPRXPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPRXPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPRXPacket* internal_default_instance() {
    return reinterpret_cast<const SPRXPacket*>(
               &_SPRXPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SPRXPacket& a, SPRXPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(SPRXPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPRXPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPRXPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPRXPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPRXPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SPRXPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPRXPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SPRXPacket";
  }
  protected:
  explicit SPRXPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kHandleFieldNumber = 2,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 Handle = 2;
  void clear_handle();
  int32_t handle() const;
  void set_handle(int32_t value);
  private:
  int32_t _internal_handle() const;
  void _internal_set_handle(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SPRXPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  int32_t handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class MemoryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MemoryInfo) */ {
 public:
  inline MemoryInfo() : MemoryInfo(nullptr) {}
  ~MemoryInfo() override;
  explicit constexpr MemoryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemoryInfo(const MemoryInfo& from);
  MemoryInfo(MemoryInfo&& from) noexcept
    : MemoryInfo() {
    *this = ::std::move(from);
  }

  inline MemoryInfo& operator=(const MemoryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryInfo& operator=(MemoryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemoryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoryInfo* internal_default_instance() {
    return reinterpret_cast<const MemoryInfo*>(
               &_MemoryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MemoryInfo& a, MemoryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemoryInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemoryInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MemoryInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemoryInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MemoryInfo";
  }
  protected:
  explicit MemoryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsedFieldNumber = 1,
    kFreeFieldNumber = 2,
    kTotalFieldNumber = 3,
    kPercentageFieldNumber = 4,
  };
  // int32 Used = 1;
  void clear_used();
  int32_t used() const;
  void set_used(int32_t value);
  private:
  int32_t _internal_used() const;
  void _internal_set_used(int32_t value);
  public:

  // int32 Free = 2;
  void clear_free();
  int32_t free() const;
  void set_free(int32_t value);
  private:
  int32_t _internal_free() const;
  void _internal_set_free(int32_t value);
  public:

  // int32 Total = 3;
  void clear_total();
  int32_t total() const;
  void set_total(int32_t value);
  private:
  int32_t _internal_total() const;
  void _internal_set_total(int32_t value);
  public:

  // float Percentage = 4;
  void clear_percentage();
  float percentage() const;
  void set_percentage(float value);
  private:
  float _internal_percentage() const;
  void _internal_set_percentage(float value);
  public:

  // @@protoc_insertion_point(class_scope:MemoryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t used_;
  int32_t free_;
  int32_t total_;
  float percentage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class CurrentBigApp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CurrentBigApp) */ {
 public:
  inline CurrentBigApp() : CurrentBigApp(nullptr) {}
  ~CurrentBigApp() override;
  explicit constexpr CurrentBigApp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrentBigApp(const CurrentBigApp& from);
  CurrentBigApp(CurrentBigApp&& from) noexcept
    : CurrentBigApp() {
    *this = ::std::move(from);
  }

  inline CurrentBigApp& operator=(const CurrentBigApp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentBigApp& operator=(CurrentBigApp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrentBigApp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrentBigApp* internal_default_instance() {
    return reinterpret_cast<const CurrentBigApp*>(
               &_CurrentBigApp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CurrentBigApp& a, CurrentBigApp& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentBigApp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentBigApp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrentBigApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrentBigApp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrentBigApp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CurrentBigApp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentBigApp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CurrentBigApp";
  }
  protected:
  explicit CurrentBigApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTitleIdFieldNumber = 3,
    kPidFieldNumber = 1,
  };
  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string TitleId = 3;
  void clear_titleid();
  const std::string& titleid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titleid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titleid();
  PROTOBUF_NODISCARD std::string* release_titleid();
  void set_allocated_titleid(std::string* titleid);
  private:
  const std::string& _internal_titleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titleid(const std::string& value);
  std::string* _internal_mutable_titleid();
  public:

  // int32 Pid = 1;
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CurrentBigApp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titleid_;
  int32_t pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class TargetInfoPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TargetInfoPacket) */ {
 public:
  inline TargetInfoPacket() : TargetInfoPacket(nullptr) {}
  ~TargetInfoPacket() override;
  explicit constexpr TargetInfoPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetInfoPacket(const TargetInfoPacket& from);
  TargetInfoPacket(TargetInfoPacket&& from) noexcept
    : TargetInfoPacket() {
    *this = ::std::move(from);
  }

  inline TargetInfoPacket& operator=(const TargetInfoPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetInfoPacket& operator=(TargetInfoPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetInfoPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetInfoPacket* internal_default_instance() {
    return reinterpret_cast<const TargetInfoPacket*>(
               &_TargetInfoPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TargetInfoPacket& a, TargetInfoPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetInfoPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetInfoPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetInfoPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetInfoPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetInfoPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TargetInfoPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetInfoPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TargetInfoPacket";
  }
  protected:
  explicit TargetInfoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsoleNameFieldNumber = 5,
    kMotherboardSerialFieldNumber = 6,
    kSerialFieldNumber = 7,
    kModelFieldNumber = 8,
    kMACAddressLANFieldNumber = 9,
    kMACAddressWIFIFieldNumber = 10,
    kIDPSFieldNumber = 13,
    kPSIDFieldNumber = 14,
    kBigAppFieldNumber = 4,
    kRamFieldNumber = 26,
    kVRamFieldNumber = 27,
    kSDKVersionFieldNumber = 1,
    kSoftwareVersionFieldNumber = 2,
    kFactorySoftwareVersionFieldNumber = 3,
    kUARTFieldNumber = 11,
    kIDUModeFieldNumber = 12,
    kConsoleTypeFieldNumber = 15,
    kAttachedFieldNumber = 16,
    kAttachedPidFieldNumber = 17,
    kForegroundAccountIdFieldNumber = 18,
    kFreeSpaceFieldNumber = 19,
    kTotalSpaceFieldNumber = 20,
    kCPUTempFieldNumber = 21,
    kSOCTempFieldNumber = 22,
    kThreadCountFieldNumber = 23,
    kAverageCPUUsageFieldNumber = 24,
    kBusyCoreFieldNumber = 25,
  };
  // string ConsoleName = 5;
  void clear_consolename();
  const std::string& consolename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consolename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consolename();
  PROTOBUF_NODISCARD std::string* release_consolename();
  void set_allocated_consolename(std::string* consolename);
  private:
  const std::string& _internal_consolename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consolename(const std::string& value);
  std::string* _internal_mutable_consolename();
  public:

  // string MotherboardSerial = 6;
  void clear_motherboardserial();
  const std::string& motherboardserial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_motherboardserial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_motherboardserial();
  PROTOBUF_NODISCARD std::string* release_motherboardserial();
  void set_allocated_motherboardserial(std::string* motherboardserial);
  private:
  const std::string& _internal_motherboardserial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_motherboardserial(const std::string& value);
  std::string* _internal_mutable_motherboardserial();
  public:

  // string Serial = 7;
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_NODISCARD std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // string Model = 8;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string MACAddressLAN = 9;
  void clear_macaddresslan();
  const std::string& macaddresslan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_macaddresslan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_macaddresslan();
  PROTOBUF_NODISCARD std::string* release_macaddresslan();
  void set_allocated_macaddresslan(std::string* macaddresslan);
  private:
  const std::string& _internal_macaddresslan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_macaddresslan(const std::string& value);
  std::string* _internal_mutable_macaddresslan();
  public:

  // string MACAddressWIFI = 10;
  void clear_macaddresswifi();
  const std::string& macaddresswifi() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_macaddresswifi(ArgT0&& arg0, ArgT... args);
  std::string* mutable_macaddresswifi();
  PROTOBUF_NODISCARD std::string* release_macaddresswifi();
  void set_allocated_macaddresswifi(std::string* macaddresswifi);
  private:
  const std::string& _internal_macaddresswifi() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_macaddresswifi(const std::string& value);
  std::string* _internal_mutable_macaddresswifi();
  public:

  // string IDPS = 13;
  void clear_idps();
  const std::string& idps() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idps(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idps();
  PROTOBUF_NODISCARD std::string* release_idps();
  void set_allocated_idps(std::string* idps);
  private:
  const std::string& _internal_idps() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idps(const std::string& value);
  std::string* _internal_mutable_idps();
  public:

  // string PSID = 14;
  void clear_psid();
  const std::string& psid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_psid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_psid();
  PROTOBUF_NODISCARD std::string* release_psid();
  void set_allocated_psid(std::string* psid);
  private:
  const std::string& _internal_psid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_psid(const std::string& value);
  std::string* _internal_mutable_psid();
  public:

  // .CurrentBigApp BigApp = 4;
  bool has_bigapp() const;
  private:
  bool _internal_has_bigapp() const;
  public:
  void clear_bigapp();
  const ::CurrentBigApp& bigapp() const;
  PROTOBUF_NODISCARD ::CurrentBigApp* release_bigapp();
  ::CurrentBigApp* mutable_bigapp();
  void set_allocated_bigapp(::CurrentBigApp* bigapp);
  private:
  const ::CurrentBigApp& _internal_bigapp() const;
  ::CurrentBigApp* _internal_mutable_bigapp();
  public:
  void unsafe_arena_set_allocated_bigapp(
      ::CurrentBigApp* bigapp);
  ::CurrentBigApp* unsafe_arena_release_bigapp();

  // .MemoryInfo Ram = 26;
  bool has_ram() const;
  private:
  bool _internal_has_ram() const;
  public:
  void clear_ram();
  const ::MemoryInfo& ram() const;
  PROTOBUF_NODISCARD ::MemoryInfo* release_ram();
  ::MemoryInfo* mutable_ram();
  void set_allocated_ram(::MemoryInfo* ram);
  private:
  const ::MemoryInfo& _internal_ram() const;
  ::MemoryInfo* _internal_mutable_ram();
  public:
  void unsafe_arena_set_allocated_ram(
      ::MemoryInfo* ram);
  ::MemoryInfo* unsafe_arena_release_ram();

  // .MemoryInfo VRam = 27;
  bool has_vram() const;
  private:
  bool _internal_has_vram() const;
  public:
  void clear_vram();
  const ::MemoryInfo& vram() const;
  PROTOBUF_NODISCARD ::MemoryInfo* release_vram();
  ::MemoryInfo* mutable_vram();
  void set_allocated_vram(::MemoryInfo* vram);
  private:
  const ::MemoryInfo& _internal_vram() const;
  ::MemoryInfo* _internal_mutable_vram();
  public:
  void unsafe_arena_set_allocated_vram(
      ::MemoryInfo* vram);
  ::MemoryInfo* unsafe_arena_release_vram();

  // int32 SDKVersion = 1;
  void clear_sdkversion();
  int32_t sdkversion() const;
  void set_sdkversion(int32_t value);
  private:
  int32_t _internal_sdkversion() const;
  void _internal_set_sdkversion(int32_t value);
  public:

  // int32 SoftwareVersion = 2;
  void clear_softwareversion();
  int32_t softwareversion() const;
  void set_softwareversion(int32_t value);
  private:
  int32_t _internal_softwareversion() const;
  void _internal_set_softwareversion(int32_t value);
  public:

  // int32 FactorySoftwareVersion = 3;
  void clear_factorysoftwareversion();
  int32_t factorysoftwareversion() const;
  void set_factorysoftwareversion(int32_t value);
  private:
  int32_t _internal_factorysoftwareversion() const;
  void _internal_set_factorysoftwareversion(int32_t value);
  public:

  // bool UART = 11;
  void clear_uart();
  bool uart() const;
  void set_uart(bool value);
  private:
  bool _internal_uart() const;
  void _internal_set_uart(bool value);
  public:

  // bool IDUMode = 12;
  void clear_idumode();
  bool idumode() const;
  void set_idumode(bool value);
  private:
  bool _internal_idumode() const;
  void _internal_set_idumode(bool value);
  public:

  // int32 ConsoleType = 15;
  void clear_consoletype();
  int32_t consoletype() const;
  void set_consoletype(int32_t value);
  private:
  int32_t _internal_consoletype() const;
  void _internal_set_consoletype(int32_t value);
  public:

  // int32 Attached = 16;
  void clear_attached();
  int32_t attached() const;
  void set_attached(int32_t value);
  private:
  int32_t _internal_attached() const;
  void _internal_set_attached(int32_t value);
  public:

  // int32 AttachedPid = 17;
  void clear_attachedpid();
  int32_t attachedpid() const;
  void set_attachedpid(int32_t value);
  private:
  int32_t _internal_attachedpid() const;
  void _internal_set_attachedpid(int32_t value);
  public:

  // int32 ForegroundAccountId = 18;
  void clear_foregroundaccountid();
  int32_t foregroundaccountid() const;
  void set_foregroundaccountid(int32_t value);
  private:
  int32_t _internal_foregroundaccountid() const;
  void _internal_set_foregroundaccountid(int32_t value);
  public:

  // uint64 FreeSpace = 19;
  void clear_freespace();
  uint64_t freespace() const;
  void set_freespace(uint64_t value);
  private:
  uint64_t _internal_freespace() const;
  void _internal_set_freespace(uint64_t value);
  public:

  // uint64 TotalSpace = 20;
  void clear_totalspace();
  uint64_t totalspace() const;
  void set_totalspace(uint64_t value);
  private:
  uint64_t _internal_totalspace() const;
  void _internal_set_totalspace(uint64_t value);
  public:

  // int32 CPUTemp = 21;
  void clear_cputemp();
  int32_t cputemp() const;
  void set_cputemp(int32_t value);
  private:
  int32_t _internal_cputemp() const;
  void _internal_set_cputemp(int32_t value);
  public:

  // int32 SOCTemp = 22;
  void clear_soctemp();
  int32_t soctemp() const;
  void set_soctemp(int32_t value);
  private:
  int32_t _internal_soctemp() const;
  void _internal_set_soctemp(int32_t value);
  public:

  // int32 ThreadCount = 23;
  void clear_threadcount();
  int32_t threadcount() const;
  void set_threadcount(int32_t value);
  private:
  int32_t _internal_threadcount() const;
  void _internal_set_threadcount(int32_t value);
  public:

  // float AverageCPUUsage = 24;
  void clear_averagecpuusage();
  float averagecpuusage() const;
  void set_averagecpuusage(float value);
  private:
  float _internal_averagecpuusage() const;
  void _internal_set_averagecpuusage(float value);
  public:

  // int32 BusyCore = 25;
  void clear_busycore();
  int32_t busycore() const;
  void set_busycore(int32_t value);
  private:
  int32_t _internal_busycore() const;
  void _internal_set_busycore(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TargetInfoPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consolename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr motherboardserial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macaddresslan_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macaddresswifi_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idps_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr psid_;
  ::CurrentBigApp* bigapp_;
  ::MemoryInfo* ram_;
  ::MemoryInfo* vram_;
  int32_t sdkversion_;
  int32_t softwareversion_;
  int32_t factorysoftwareversion_;
  bool uart_;
  bool idumode_;
  int32_t consoletype_;
  int32_t attached_;
  int32_t attachedpid_;
  int32_t foregroundaccountid_;
  uint64_t freespace_;
  uint64_t totalspace_;
  int32_t cputemp_;
  int32_t soctemp_;
  int32_t threadcount_;
  float averagecpuusage_;
  int32_t busycore_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class TargetNotifyPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TargetNotifyPacket) */ {
 public:
  inline TargetNotifyPacket() : TargetNotifyPacket(nullptr) {}
  ~TargetNotifyPacket() override;
  explicit constexpr TargetNotifyPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetNotifyPacket(const TargetNotifyPacket& from);
  TargetNotifyPacket(TargetNotifyPacket&& from) noexcept
    : TargetNotifyPacket() {
    *this = ::std::move(from);
  }

  inline TargetNotifyPacket& operator=(const TargetNotifyPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetNotifyPacket& operator=(TargetNotifyPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetNotifyPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetNotifyPacket* internal_default_instance() {
    return reinterpret_cast<const TargetNotifyPacket*>(
               &_TargetNotifyPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TargetNotifyPacket& a, TargetNotifyPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetNotifyPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetNotifyPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetNotifyPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetNotifyPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetNotifyPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TargetNotifyPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetNotifyPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TargetNotifyPacket";
  }
  protected:
  explicit TargetNotifyPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIconURIFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string IconURI = 1;
  void clear_iconuri();
  const std::string& iconuri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iconuri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iconuri();
  PROTOBUF_NODISCARD std::string* release_iconuri();
  void set_allocated_iconuri(std::string* iconuri);
  private:
  const std::string& _internal_iconuri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iconuri(const std::string& value);
  std::string* _internal_mutable_iconuri();
  public:

  // string Message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:TargetNotifyPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iconuri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class TargetSettingsPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TargetSettingsPacket) */ {
 public:
  inline TargetSettingsPacket() : TargetSettingsPacket(nullptr) {}
  ~TargetSettingsPacket() override;
  explicit constexpr TargetSettingsPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetSettingsPacket(const TargetSettingsPacket& from);
  TargetSettingsPacket(TargetSettingsPacket&& from) noexcept
    : TargetSettingsPacket() {
    *this = ::std::move(from);
  }

  inline TargetSettingsPacket& operator=(const TargetSettingsPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetSettingsPacket& operator=(TargetSettingsPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetSettingsPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetSettingsPacket* internal_default_instance() {
    return reinterpret_cast<const TargetSettingsPacket*>(
               &_TargetSettingsPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TargetSettingsPacket& a, TargetSettingsPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetSettingsPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetSettingsPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetSettingsPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetSettingsPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetSettingsPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TargetSettingsPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetSettingsPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TargetSettingsPacket";
  }
  protected:
  explicit TargetSettingsPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameOverlayLocationFieldNumber = 7,
    kAutoLoadSettingsFieldNumber = 1,
    kShowDebugTitleIdLabelFieldNumber = 2,
    kShowDevkitPanelFieldNumber = 3,
    kShowDebugSettingsFieldNumber = 4,
    kShowAppHomeFieldNumber = 5,
    kShowBuildOverlayFieldNumber = 6,
    kShowCPUUsageFieldNumber = 8,
    kShowThreadCountFieldNumber = 9,
    kShowramFieldNumber = 10,
    kShowvramFieldNumber = 11,
    kShowCPUTempFieldNumber = 12,
    kShowSOCTempFieldNumber = 13,
  };
  // string GameOverlayLocation = 7;
  void clear_gameoverlaylocation();
  const std::string& gameoverlaylocation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gameoverlaylocation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gameoverlaylocation();
  PROTOBUF_NODISCARD std::string* release_gameoverlaylocation();
  void set_allocated_gameoverlaylocation(std::string* gameoverlaylocation);
  private:
  const std::string& _internal_gameoverlaylocation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gameoverlaylocation(const std::string& value);
  std::string* _internal_mutable_gameoverlaylocation();
  public:

  // bool AutoLoadSettings = 1;
  void clear_autoloadsettings();
  bool autoloadsettings() const;
  void set_autoloadsettings(bool value);
  private:
  bool _internal_autoloadsettings() const;
  void _internal_set_autoloadsettings(bool value);
  public:

  // bool ShowDebugTitleIdLabel = 2;
  void clear_showdebugtitleidlabel();
  bool showdebugtitleidlabel() const;
  void set_showdebugtitleidlabel(bool value);
  private:
  bool _internal_showdebugtitleidlabel() const;
  void _internal_set_showdebugtitleidlabel(bool value);
  public:

  // bool ShowDevkitPanel = 3;
  void clear_showdevkitpanel();
  bool showdevkitpanel() const;
  void set_showdevkitpanel(bool value);
  private:
  bool _internal_showdevkitpanel() const;
  void _internal_set_showdevkitpanel(bool value);
  public:

  // bool ShowDebugSettings = 4;
  void clear_showdebugsettings();
  bool showdebugsettings() const;
  void set_showdebugsettings(bool value);
  private:
  bool _internal_showdebugsettings() const;
  void _internal_set_showdebugsettings(bool value);
  public:

  // bool ShowAppHome = 5;
  void clear_showapphome();
  bool showapphome() const;
  void set_showapphome(bool value);
  private:
  bool _internal_showapphome() const;
  void _internal_set_showapphome(bool value);
  public:

  // bool ShowBuildOverlay = 6;
  void clear_showbuildoverlay();
  bool showbuildoverlay() const;
  void set_showbuildoverlay(bool value);
  private:
  bool _internal_showbuildoverlay() const;
  void _internal_set_showbuildoverlay(bool value);
  public:

  // bool ShowCPUUsage = 8;
  void clear_showcpuusage();
  bool showcpuusage() const;
  void set_showcpuusage(bool value);
  private:
  bool _internal_showcpuusage() const;
  void _internal_set_showcpuusage(bool value);
  public:

  // bool ShowThreadCount = 9;
  void clear_showthreadcount();
  bool showthreadcount() const;
  void set_showthreadcount(bool value);
  private:
  bool _internal_showthreadcount() const;
  void _internal_set_showthreadcount(bool value);
  public:

  // bool Showram = 10;
  void clear_showram();
  bool showram() const;
  void set_showram(bool value);
  private:
  bool _internal_showram() const;
  void _internal_set_showram(bool value);
  public:

  // bool Showvram = 11;
  void clear_showvram();
  bool showvram() const;
  void set_showvram(bool value);
  private:
  bool _internal_showvram() const;
  void _internal_set_showvram(bool value);
  public:

  // bool ShowCPUTemp = 12;
  void clear_showcputemp();
  bool showcputemp() const;
  void set_showcputemp(bool value);
  private:
  bool _internal_showcputemp() const;
  void _internal_set_showcputemp(bool value);
  public:

  // bool ShowSOCTemp = 13;
  void clear_showsoctemp();
  bool showsoctemp() const;
  void set_showsoctemp(bool value);
  private:
  bool _internal_showsoctemp() const;
  void _internal_set_showsoctemp(bool value);
  public:

  // @@protoc_insertion_point(class_scope:TargetSettingsPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gameoverlaylocation_;
  bool autoloadsettings_;
  bool showdebugtitleidlabel_;
  bool showdevkitpanel_;
  bool showdebugsettings_;
  bool showapphome_;
  bool showbuildoverlay_;
  bool showcpuusage_;
  bool showthreadcount_;
  bool showram_;
  bool showvram_;
  bool showcputemp_;
  bool showsoctemp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class ProcPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProcPacket) */ {
 public:
  inline ProcPacket() : ProcPacket(nullptr) {}
  ~ProcPacket() override;
  explicit constexpr ProcPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcPacket(const ProcPacket& from);
  ProcPacket(ProcPacket&& from) noexcept
    : ProcPacket() {
    *this = ::std::move(from);
  }

  inline ProcPacket& operator=(const ProcPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcPacket& operator=(ProcPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcPacket* internal_default_instance() {
    return reinterpret_cast<const ProcPacket*>(
               &_ProcPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ProcPacket& a, ProcPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProcPacket";
  }
  protected:
  explicit ProcPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kTitleIdFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kProcessIdFieldNumber = 2,
  };
  // string Name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string TitleId = 4;
  void clear_titleid();
  const std::string& titleid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titleid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titleid();
  PROTOBUF_NODISCARD std::string* release_titleid();
  void set_allocated_titleid(std::string* titleid);
  private:
  const std::string& _internal_titleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titleid(const std::string& value);
  std::string* _internal_mutable_titleid();
  public:

  // int32 AppId = 1;
  void clear_appid();
  int32_t appid() const;
  void set_appid(int32_t value);
  private:
  int32_t _internal_appid() const;
  void _internal_set_appid(int32_t value);
  public:

  // int32 ProcessId = 2;
  void clear_processid();
  int32_t processid() const;
  void set_processid(int32_t value);
  private:
  int32_t _internal_processid() const;
  void _internal_set_processid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProcPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titleid_;
  int32_t appid_;
  int32_t processid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class ProcListPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProcListPacket) */ {
 public:
  inline ProcListPacket() : ProcListPacket(nullptr) {}
  ~ProcListPacket() override;
  explicit constexpr ProcListPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcListPacket(const ProcListPacket& from);
  ProcListPacket(ProcListPacket&& from) noexcept
    : ProcListPacket() {
    *this = ::std::move(from);
  }

  inline ProcListPacket& operator=(const ProcListPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcListPacket& operator=(ProcListPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcListPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcListPacket* internal_default_instance() {
    return reinterpret_cast<const ProcListPacket*>(
               &_ProcListPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ProcListPacket& a, ProcListPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcListPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcListPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcListPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcListPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcListPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcListPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcListPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProcListPacket";
  }
  protected:
  explicit ProcListPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcessesFieldNumber = 1,
  };
  // repeated .ProcPacket Processes = 1;
  int processes_size() const;
  private:
  int _internal_processes_size() const;
  public:
  void clear_processes();
  ::ProcPacket* mutable_processes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProcPacket >*
      mutable_processes();
  private:
  const ::ProcPacket& _internal_processes(int index) const;
  ::ProcPacket* _internal_add_processes();
  public:
  const ::ProcPacket& processes(int index) const;
  ::ProcPacket* add_processes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProcPacket >&
      processes() const;

  // @@protoc_insertion_point(class_scope:ProcListPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProcPacket > processes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class LibraryInfoPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LibraryInfoPacket) */ {
 public:
  inline LibraryInfoPacket() : LibraryInfoPacket(nullptr) {}
  ~LibraryInfoPacket() override;
  explicit constexpr LibraryInfoPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibraryInfoPacket(const LibraryInfoPacket& from);
  LibraryInfoPacket(LibraryInfoPacket&& from) noexcept
    : LibraryInfoPacket() {
    *this = ::std::move(from);
  }

  inline LibraryInfoPacket& operator=(const LibraryInfoPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibraryInfoPacket& operator=(LibraryInfoPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibraryInfoPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibraryInfoPacket* internal_default_instance() {
    return reinterpret_cast<const LibraryInfoPacket*>(
               &_LibraryInfoPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LibraryInfoPacket& a, LibraryInfoPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(LibraryInfoPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibraryInfoPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibraryInfoPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibraryInfoPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibraryInfoPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LibraryInfoPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibraryInfoPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LibraryInfoPacket";
  }
  protected:
  explicit LibraryInfoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kMapBaseFieldNumber = 3,
    kMapSizeFieldNumber = 4,
    kTextSizeFieldNumber = 5,
    kDataBaseFieldNumber = 6,
    kDataSizeFieldNumber = 7,
    kHandleFieldNumber = 1,
  };
  // string Path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // uint64 MapBase = 3;
  void clear_mapbase();
  uint64_t mapbase() const;
  void set_mapbase(uint64_t value);
  private:
  uint64_t _internal_mapbase() const;
  void _internal_set_mapbase(uint64_t value);
  public:

  // uint64 MapSize = 4;
  void clear_mapsize();
  uint64_t mapsize() const;
  void set_mapsize(uint64_t value);
  private:
  uint64_t _internal_mapsize() const;
  void _internal_set_mapsize(uint64_t value);
  public:

  // uint64 TextSize = 5;
  void clear_textsize();
  uint64_t textsize() const;
  void set_textsize(uint64_t value);
  private:
  uint64_t _internal_textsize() const;
  void _internal_set_textsize(uint64_t value);
  public:

  // uint64 DataBase = 6;
  void clear_database();
  uint64_t database() const;
  void set_database(uint64_t value);
  private:
  uint64_t _internal_database() const;
  void _internal_set_database(uint64_t value);
  public:

  // uint64 DataSize = 7;
  void clear_datasize();
  uint64_t datasize() const;
  void set_datasize(uint64_t value);
  private:
  uint64_t _internal_datasize() const;
  void _internal_set_datasize(uint64_t value);
  public:

  // uint32 Handle = 1;
  void clear_handle();
  uint32_t handle() const;
  void set_handle(uint32_t value);
  private:
  uint32_t _internal_handle() const;
  void _internal_set_handle(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LibraryInfoPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  uint64_t mapbase_;
  uint64_t mapsize_;
  uint64_t textsize_;
  uint64_t database_;
  uint64_t datasize_;
  uint32_t handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class LibraryListPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LibraryListPacket) */ {
 public:
  inline LibraryListPacket() : LibraryListPacket(nullptr) {}
  ~LibraryListPacket() override;
  explicit constexpr LibraryListPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibraryListPacket(const LibraryListPacket& from);
  LibraryListPacket(LibraryListPacket&& from) noexcept
    : LibraryListPacket() {
    *this = ::std::move(from);
  }

  inline LibraryListPacket& operator=(const LibraryListPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibraryListPacket& operator=(LibraryListPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibraryListPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibraryListPacket* internal_default_instance() {
    return reinterpret_cast<const LibraryListPacket*>(
               &_LibraryListPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LibraryListPacket& a, LibraryListPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(LibraryListPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibraryListPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibraryListPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibraryListPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibraryListPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LibraryListPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibraryListPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LibraryListPacket";
  }
  protected:
  explicit LibraryListPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLibrariesFieldNumber = 1,
  };
  // repeated .LibraryInfoPacket Libraries = 1;
  int libraries_size() const;
  private:
  int _internal_libraries_size() const;
  public:
  void clear_libraries();
  ::LibraryInfoPacket* mutable_libraries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LibraryInfoPacket >*
      mutable_libraries();
  private:
  const ::LibraryInfoPacket& _internal_libraries(int index) const;
  ::LibraryInfoPacket* _internal_add_libraries();
  public:
  const ::LibraryInfoPacket& libraries(int index) const;
  ::LibraryInfoPacket* add_libraries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LibraryInfoPacket >&
      libraries() const;

  // @@protoc_insertion_point(class_scope:LibraryListPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LibraryInfoPacket > libraries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class PagePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PagePacket) */ {
 public:
  inline PagePacket() : PagePacket(nullptr) {}
  ~PagePacket() override;
  explicit constexpr PagePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PagePacket(const PagePacket& from);
  PagePacket(PagePacket&& from) noexcept
    : PagePacket() {
    *this = ::std::move(from);
  }

  inline PagePacket& operator=(const PagePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline PagePacket& operator=(PagePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PagePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const PagePacket* internal_default_instance() {
    return reinterpret_cast<const PagePacket*>(
               &_PagePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PagePacket& a, PagePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(PagePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PagePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PagePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PagePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PagePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PagePacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PagePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PagePacket";
  }
  protected:
  explicit PagePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kStartFieldNumber = 2,
    kEndFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kSizeFieldNumber = 5,
    kProtFieldNumber = 6,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 Start = 2;
  void clear_start();
  uint64_t start() const;
  void set_start(uint64_t value);
  private:
  uint64_t _internal_start() const;
  void _internal_set_start(uint64_t value);
  public:

  // uint64 End = 3;
  void clear_end();
  uint64_t end() const;
  void set_end(uint64_t value);
  private:
  uint64_t _internal_end() const;
  void _internal_set_end(uint64_t value);
  public:

  // uint64 Offset = 4;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint64 Size = 5;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // uint32 Prot = 6;
  void clear_prot();
  uint32_t prot() const;
  void set_prot(uint32_t value);
  private:
  uint32_t _internal_prot() const;
  void _internal_set_prot(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:PagePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t start_;
  uint64_t end_;
  uint64_t offset_;
  uint64_t size_;
  uint32_t prot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class PagesListPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PagesListPacket) */ {
 public:
  inline PagesListPacket() : PagesListPacket(nullptr) {}
  ~PagesListPacket() override;
  explicit constexpr PagesListPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PagesListPacket(const PagesListPacket& from);
  PagesListPacket(PagesListPacket&& from) noexcept
    : PagesListPacket() {
    *this = ::std::move(from);
  }

  inline PagesListPacket& operator=(const PagesListPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline PagesListPacket& operator=(PagesListPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PagesListPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const PagesListPacket* internal_default_instance() {
    return reinterpret_cast<const PagesListPacket*>(
               &_PagesListPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PagesListPacket& a, PagesListPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(PagesListPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PagesListPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PagesListPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PagesListPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PagesListPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PagesListPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PagesListPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PagesListPacket";
  }
  protected:
  explicit PagesListPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPagesFieldNumber = 1,
  };
  // repeated .PagePacket Pages = 1;
  int pages_size() const;
  private:
  int _internal_pages_size() const;
  public:
  void clear_pages();
  ::PagePacket* mutable_pages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PagePacket >*
      mutable_pages();
  private:
  const ::PagePacket& _internal_pages(int index) const;
  ::PagePacket* _internal_add_pages();
  public:
  const ::PagePacket& pages(int index) const;
  ::PagePacket* add_pages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PagePacket >&
      pages() const;

  // @@protoc_insertion_point(class_scope:PagesListPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PagePacket > pages_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class NamedObjectPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NamedObjectPacket) */ {
 public:
  inline NamedObjectPacket() : NamedObjectPacket(nullptr) {}
  ~NamedObjectPacket() override;
  explicit constexpr NamedObjectPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedObjectPacket(const NamedObjectPacket& from);
  NamedObjectPacket(NamedObjectPacket&& from) noexcept
    : NamedObjectPacket() {
    *this = ::std::move(from);
  }

  inline NamedObjectPacket& operator=(const NamedObjectPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedObjectPacket& operator=(NamedObjectPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedObjectPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedObjectPacket* internal_default_instance() {
    return reinterpret_cast<const NamedObjectPacket*>(
               &_NamedObjectPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(NamedObjectPacket& a, NamedObjectPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedObjectPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedObjectPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedObjectPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedObjectPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedObjectPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NamedObjectPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedObjectPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NamedObjectPacket";
  }
  protected:
  explicit NamedObjectPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:NamedObjectPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class NamedObjectListPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NamedObjectListPacket) */ {
 public:
  inline NamedObjectListPacket() : NamedObjectListPacket(nullptr) {}
  ~NamedObjectListPacket() override;
  explicit constexpr NamedObjectListPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedObjectListPacket(const NamedObjectListPacket& from);
  NamedObjectListPacket(NamedObjectListPacket&& from) noexcept
    : NamedObjectListPacket() {
    *this = ::std::move(from);
  }

  inline NamedObjectListPacket& operator=(const NamedObjectListPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedObjectListPacket& operator=(NamedObjectListPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamedObjectListPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedObjectListPacket* internal_default_instance() {
    return reinterpret_cast<const NamedObjectListPacket*>(
               &_NamedObjectListPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(NamedObjectListPacket& a, NamedObjectListPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedObjectListPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedObjectListPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedObjectListPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedObjectListPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamedObjectListPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NamedObjectListPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamedObjectListPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NamedObjectListPacket";
  }
  protected:
  explicit NamedObjectListPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 1,
  };
  // repeated .NamedObjectPacket Objects = 1;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::NamedObjectPacket* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NamedObjectPacket >*
      mutable_objects();
  private:
  const ::NamedObjectPacket& _internal_objects(int index) const;
  ::NamedObjectPacket* _internal_add_objects();
  public:
  const ::NamedObjectPacket& objects(int index) const;
  ::NamedObjectPacket* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NamedObjectPacket >&
      objects() const;

  // @@protoc_insertion_point(class_scope:NamedObjectListPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NamedObjectPacket > objects_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class FilePacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FilePacket) */ {
 public:
  inline FilePacket() : FilePacket(nullptr) {}
  ~FilePacket() override;
  explicit constexpr FilePacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilePacket(const FilePacket& from);
  FilePacket(FilePacket&& from) noexcept
    : FilePacket() {
    *this = ::std::move(from);
  }

  inline FilePacket& operator=(const FilePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilePacket& operator=(FilePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilePacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilePacket* internal_default_instance() {
    return reinterpret_cast<const FilePacket*>(
               &_FilePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(FilePacket& a, FilePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(FilePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilePacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilePacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilePacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilePacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FilePacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilePacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FilePacket";
  }
  protected:
  explicit FilePacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
  };
  // string FilePath = 1;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // @@protoc_insertion_point(class_scope:FilePacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class ThreadInfoPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ThreadInfoPacket) */ {
 public:
  inline ThreadInfoPacket() : ThreadInfoPacket(nullptr) {}
  ~ThreadInfoPacket() override;
  explicit constexpr ThreadInfoPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreadInfoPacket(const ThreadInfoPacket& from);
  ThreadInfoPacket(ThreadInfoPacket&& from) noexcept
    : ThreadInfoPacket() {
    *this = ::std::move(from);
  }

  inline ThreadInfoPacket& operator=(const ThreadInfoPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreadInfoPacket& operator=(ThreadInfoPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThreadInfoPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreadInfoPacket* internal_default_instance() {
    return reinterpret_cast<const ThreadInfoPacket*>(
               &_ThreadInfoPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ThreadInfoPacket& a, ThreadInfoPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreadInfoPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreadInfoPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreadInfoPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreadInfoPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThreadInfoPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ThreadInfoPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThreadInfoPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ThreadInfoPacket";
  }
  protected:
  explicit ThreadInfoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTIDFieldNumber = 1,
  };
  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 TID = 1;
  void clear_tid();
  uint32_t tid() const;
  void set_tid(uint32_t value);
  private:
  uint32_t _internal_tid() const;
  void _internal_set_tid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ThreadInfoPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint32_t tid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class ThreadListPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ThreadListPacket) */ {
 public:
  inline ThreadListPacket() : ThreadListPacket(nullptr) {}
  ~ThreadListPacket() override;
  explicit constexpr ThreadListPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThreadListPacket(const ThreadListPacket& from);
  ThreadListPacket(ThreadListPacket&& from) noexcept
    : ThreadListPacket() {
    *this = ::std::move(from);
  }

  inline ThreadListPacket& operator=(const ThreadListPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThreadListPacket& operator=(ThreadListPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThreadListPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThreadListPacket* internal_default_instance() {
    return reinterpret_cast<const ThreadListPacket*>(
               &_ThreadListPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ThreadListPacket& a, ThreadListPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(ThreadListPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThreadListPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ThreadListPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ThreadListPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ThreadListPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ThreadListPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThreadListPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ThreadListPacket";
  }
  protected:
  explicit ThreadListPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThreadsFieldNumber = 1,
  };
  // repeated .ThreadInfoPacket Threads = 1;
  int threads_size() const;
  private:
  int _internal_threads_size() const;
  public:
  void clear_threads();
  ::ThreadInfoPacket* mutable_threads(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ThreadInfoPacket >*
      mutable_threads();
  private:
  const ::ThreadInfoPacket& _internal_threads(int index) const;
  ::ThreadInfoPacket* _internal_add_threads();
  public:
  const ::ThreadInfoPacket& threads(int index) const;
  ::ThreadInfoPacket* add_threads();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ThreadInfoPacket >&
      threads() const;

  // @@protoc_insertion_point(class_scope:ThreadListPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ThreadInfoPacket > threads_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class WatchpointPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WatchpointPacket) */ {
 public:
  inline WatchpointPacket() : WatchpointPacket(nullptr) {}
  ~WatchpointPacket() override;
  explicit constexpr WatchpointPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchpointPacket(const WatchpointPacket& from);
  WatchpointPacket(WatchpointPacket&& from) noexcept
    : WatchpointPacket() {
    *this = ::std::move(from);
  }

  inline WatchpointPacket& operator=(const WatchpointPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchpointPacket& operator=(WatchpointPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchpointPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchpointPacket* internal_default_instance() {
    return reinterpret_cast<const WatchpointPacket*>(
               &_WatchpointPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(WatchpointPacket& a, WatchpointPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchpointPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchpointPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchpointPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchpointPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchpointPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchpointPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchpointPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WatchpointPacket";
  }
  protected:
  explicit WatchpointPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kEnabledFieldNumber = 2,
    kAddressFieldNumber = 3,
    kTypeFieldNumber = 4,
    kLengthFieldNumber = 5,
  };
  // uint32 Index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // bool Enabled = 2;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // uint64 Address = 3;
  void clear_address();
  uint64_t address() const;
  void set_address(uint64_t value);
  private:
  uint64_t _internal_address() const;
  void _internal_set_address(uint64_t value);
  public:

  // uint32 Type = 4;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // uint32 Length = 5;
  void clear_length();
  uint32_t length() const;
  void set_length(uint32_t value);
  private:
  uint32_t _internal_length() const;
  void _internal_set_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:WatchpointPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t index_;
  bool enabled_;
  uint64_t address_;
  uint32_t type_;
  uint32_t length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class WatchpointListPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WatchpointListPacket) */ {
 public:
  inline WatchpointListPacket() : WatchpointListPacket(nullptr) {}
  ~WatchpointListPacket() override;
  explicit constexpr WatchpointListPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WatchpointListPacket(const WatchpointListPacket& from);
  WatchpointListPacket(WatchpointListPacket&& from) noexcept
    : WatchpointListPacket() {
    *this = ::std::move(from);
  }

  inline WatchpointListPacket& operator=(const WatchpointListPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchpointListPacket& operator=(WatchpointListPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchpointListPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchpointListPacket* internal_default_instance() {
    return reinterpret_cast<const WatchpointListPacket*>(
               &_WatchpointListPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WatchpointListPacket& a, WatchpointListPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(WatchpointListPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchpointListPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchpointListPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WatchpointListPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WatchpointListPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WatchpointListPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WatchpointListPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WatchpointListPacket";
  }
  protected:
  explicit WatchpointListPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWatchpointsFieldNumber = 1,
  };
  // repeated .WatchpointPacket Watchpoints = 1;
  int watchpoints_size() const;
  private:
  int _internal_watchpoints_size() const;
  public:
  void clear_watchpoints();
  ::WatchpointPacket* mutable_watchpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WatchpointPacket >*
      mutable_watchpoints();
  private:
  const ::WatchpointPacket& _internal_watchpoints(int index) const;
  ::WatchpointPacket* _internal_add_watchpoints();
  public:
  const ::WatchpointPacket& watchpoints(int index) const;
  ::WatchpointPacket* add_watchpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WatchpointPacket >&
      watchpoints() const;

  // @@protoc_insertion_point(class_scope:WatchpointListPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WatchpointPacket > watchpoints_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class BreakpointPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BreakpointPacket) */ {
 public:
  inline BreakpointPacket() : BreakpointPacket(nullptr) {}
  ~BreakpointPacket() override;
  explicit constexpr BreakpointPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakpointPacket(const BreakpointPacket& from);
  BreakpointPacket(BreakpointPacket&& from) noexcept
    : BreakpointPacket() {
    *this = ::std::move(from);
  }

  inline BreakpointPacket& operator=(const BreakpointPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakpointPacket& operator=(BreakpointPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakpointPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakpointPacket* internal_default_instance() {
    return reinterpret_cast<const BreakpointPacket*>(
               &_BreakpointPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(BreakpointPacket& a, BreakpointPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakpointPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakpointPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakpointPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakpointPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakpointPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BreakpointPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakpointPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BreakpointPacket";
  }
  protected:
  explicit BreakpointPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
    kEnabledFieldNumber = 2,
    kAddressFieldNumber = 3,
  };
  // uint32 Index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // bool Enabled = 2;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // uint64 Address = 3;
  void clear_address();
  uint64_t address() const;
  void set_address(uint64_t value);
  private:
  uint64_t _internal_address() const;
  void _internal_set_address(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:BreakpointPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t index_;
  bool enabled_;
  uint64_t address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class BreakpointListPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BreakpointListPacket) */ {
 public:
  inline BreakpointListPacket() : BreakpointListPacket(nullptr) {}
  ~BreakpointListPacket() override;
  explicit constexpr BreakpointListPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakpointListPacket(const BreakpointListPacket& from);
  BreakpointListPacket(BreakpointListPacket&& from) noexcept
    : BreakpointListPacket() {
    *this = ::std::move(from);
  }

  inline BreakpointListPacket& operator=(const BreakpointListPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakpointListPacket& operator=(BreakpointListPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakpointListPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakpointListPacket* internal_default_instance() {
    return reinterpret_cast<const BreakpointListPacket*>(
               &_BreakpointListPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(BreakpointListPacket& a, BreakpointListPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakpointListPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakpointListPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakpointListPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakpointListPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakpointListPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BreakpointListPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakpointListPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BreakpointListPacket";
  }
  protected:
  explicit BreakpointListPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBreakpointsFieldNumber = 1,
  };
  // repeated .BreakpointPacket Breakpoints = 1;
  int breakpoints_size() const;
  private:
  int _internal_breakpoints_size() const;
  public:
  void clear_breakpoints();
  ::BreakpointPacket* mutable_breakpoints(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BreakpointPacket >*
      mutable_breakpoints();
  private:
  const ::BreakpointPacket& _internal_breakpoints(int index) const;
  ::BreakpointPacket* _internal_add_breakpoints();
  public:
  const ::BreakpointPacket& breakpoints(int index) const;
  ::BreakpointPacket* add_breakpoints();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BreakpointPacket >&
      breakpoints() const;

  // @@protoc_insertion_point(class_scope:BreakpointListPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BreakpointPacket > breakpoints_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class SetProcessProtPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SetProcessProtPacket) */ {
 public:
  inline SetProcessProtPacket() : SetProcessProtPacket(nullptr) {}
  ~SetProcessProtPacket() override;
  explicit constexpr SetProcessProtPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetProcessProtPacket(const SetProcessProtPacket& from);
  SetProcessProtPacket(SetProcessProtPacket&& from) noexcept
    : SetProcessProtPacket() {
    *this = ::std::move(from);
  }

  inline SetProcessProtPacket& operator=(const SetProcessProtPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProcessProtPacket& operator=(SetProcessProtPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetProcessProtPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetProcessProtPacket* internal_default_instance() {
    return reinterpret_cast<const SetProcessProtPacket*>(
               &_SetProcessProtPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SetProcessProtPacket& a, SetProcessProtPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProcessProtPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProcessProtPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetProcessProtPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetProcessProtPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetProcessProtPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SetProcessProtPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProcessProtPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SetProcessProtPacket";
  }
  protected:
  explicit SetProcessProtPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kSizeFieldNumber = 2,
    kProtFieldNumber = 3,
  };
  // uint64 Address = 1;
  void clear_address();
  uint64_t address() const;
  void set_address(uint64_t value);
  private:
  uint64_t _internal_address() const;
  void _internal_set_address(uint64_t value);
  public:

  // uint64 Size = 2;
  void clear_size();
  uint64_t size() const;
  void set_size(uint64_t value);
  private:
  uint64_t _internal_size() const;
  void _internal_set_size(uint64_t value);
  public:

  // int32 Prot = 3;
  void clear_prot();
  int32_t prot() const;
  void set_prot(int32_t value);
  private:
  int32_t _internal_prot() const;
  void _internal_set_prot(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SetProcessProtPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t address_;
  uint64_t size_;
  int32_t prot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class Envxmm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Envxmm) */ {
 public:
  inline Envxmm() : Envxmm(nullptr) {}
  ~Envxmm() override;
  explicit constexpr Envxmm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Envxmm(const Envxmm& from);
  Envxmm(Envxmm&& from) noexcept
    : Envxmm() {
    *this = ::std::move(from);
  }

  inline Envxmm& operator=(const Envxmm& from) {
    CopyFrom(from);
    return *this;
  }
  inline Envxmm& operator=(Envxmm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Envxmm& default_instance() {
    return *internal_default_instance();
  }
  static inline const Envxmm* internal_default_instance() {
    return reinterpret_cast<const Envxmm*>(
               &_Envxmm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Envxmm& a, Envxmm& b) {
    a.Swap(&b);
  }
  inline void Swap(Envxmm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Envxmm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Envxmm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Envxmm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Envxmm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Envxmm& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Envxmm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Envxmm";
  }
  protected:
  explicit Envxmm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnCwFieldNumber = 1,
    kEnSwFieldNumber = 2,
    kEnTwFieldNumber = 3,
    kEnZeroFieldNumber = 4,
    kEnRipFieldNumber = 6,
    kEnOpcodeFieldNumber = 5,
    kEnMxcsrFieldNumber = 8,
    kEnRdpFieldNumber = 7,
    kEnMxcsrMaskFieldNumber = 9,
  };
  // uint32 en_cw = 1;
  void clear_en_cw();
  uint32_t en_cw() const;
  void set_en_cw(uint32_t value);
  private:
  uint32_t _internal_en_cw() const;
  void _internal_set_en_cw(uint32_t value);
  public:

  // uint32 en_sw = 2;
  void clear_en_sw();
  uint32_t en_sw() const;
  void set_en_sw(uint32_t value);
  private:
  uint32_t _internal_en_sw() const;
  void _internal_set_en_sw(uint32_t value);
  public:

  // uint32 en_tw = 3;
  void clear_en_tw();
  uint32_t en_tw() const;
  void set_en_tw(uint32_t value);
  private:
  uint32_t _internal_en_tw() const;
  void _internal_set_en_tw(uint32_t value);
  public:

  // uint32 en_zero = 4;
  void clear_en_zero();
  uint32_t en_zero() const;
  void set_en_zero(uint32_t value);
  private:
  uint32_t _internal_en_zero() const;
  void _internal_set_en_zero(uint32_t value);
  public:

  // uint64 en_rip = 6;
  void clear_en_rip();
  uint64_t en_rip() const;
  void set_en_rip(uint64_t value);
  private:
  uint64_t _internal_en_rip() const;
  void _internal_set_en_rip(uint64_t value);
  public:

  // uint32 en_opcode = 5;
  void clear_en_opcode();
  uint32_t en_opcode() const;
  void set_en_opcode(uint32_t value);
  private:
  uint32_t _internal_en_opcode() const;
  void _internal_set_en_opcode(uint32_t value);
  public:

  // uint32 en_mxcsr = 8;
  void clear_en_mxcsr();
  uint32_t en_mxcsr() const;
  void set_en_mxcsr(uint32_t value);
  private:
  uint32_t _internal_en_mxcsr() const;
  void _internal_set_en_mxcsr(uint32_t value);
  public:

  // uint64 en_rdp = 7;
  void clear_en_rdp();
  uint64_t en_rdp() const;
  void set_en_rdp(uint64_t value);
  private:
  uint64_t _internal_en_rdp() const;
  void _internal_set_en_rdp(uint64_t value);
  public:

  // uint32 en_mxcsr_mask = 9;
  void clear_en_mxcsr_mask();
  uint32_t en_mxcsr_mask() const;
  void set_en_mxcsr_mask(uint32_t value);
  private:
  uint32_t _internal_en_mxcsr_mask() const;
  void _internal_set_en_mxcsr_mask(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Envxmm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t en_cw_;
  uint32_t en_sw_;
  uint32_t en_tw_;
  uint32_t en_zero_;
  uint64_t en_rip_;
  uint32_t en_opcode_;
  uint32_t en_mxcsr_;
  uint64_t en_rdp_;
  uint32_t en_mxcsr_mask_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class Acc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Acc) */ {
 public:
  inline Acc() : Acc(nullptr) {}
  ~Acc() override;
  explicit constexpr Acc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Acc(const Acc& from);
  Acc(Acc&& from) noexcept
    : Acc() {
    *this = ::std::move(from);
  }

  inline Acc& operator=(const Acc& from) {
    CopyFrom(from);
    return *this;
  }
  inline Acc& operator=(Acc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Acc& default_instance() {
    return *internal_default_instance();
  }
  static inline const Acc* internal_default_instance() {
    return reinterpret_cast<const Acc*>(
               &_Acc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Acc& a, Acc& b) {
    a.Swap(&b);
  }
  inline void Swap(Acc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Acc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Acc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Acc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Acc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Acc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Acc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Acc";
  }
  protected:
  explicit Acc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFpBytesFieldNumber = 1,
  };
  // bytes fp_bytes = 1;
  void clear_fp_bytes();
  const std::string& fp_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fp_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fp_bytes();
  PROTOBUF_NODISCARD std::string* release_fp_bytes();
  void set_allocated_fp_bytes(std::string* fp_bytes);
  private:
  const std::string& _internal_fp_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fp_bytes(const std::string& value);
  std::string* _internal_mutable_fp_bytes();
  public:

  // @@protoc_insertion_point(class_scope:Acc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fp_bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class Xmmacc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Xmmacc) */ {
 public:
  inline Xmmacc() : Xmmacc(nullptr) {}
  ~Xmmacc() override;
  explicit constexpr Xmmacc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Xmmacc(const Xmmacc& from);
  Xmmacc(Xmmacc&& from) noexcept
    : Xmmacc() {
    *this = ::std::move(from);
  }

  inline Xmmacc& operator=(const Xmmacc& from) {
    CopyFrom(from);
    return *this;
  }
  inline Xmmacc& operator=(Xmmacc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Xmmacc& default_instance() {
    return *internal_default_instance();
  }
  static inline const Xmmacc* internal_default_instance() {
    return reinterpret_cast<const Xmmacc*>(
               &_Xmmacc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Xmmacc& a, Xmmacc& b) {
    a.Swap(&b);
  }
  inline void Swap(Xmmacc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Xmmacc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Xmmacc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Xmmacc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Xmmacc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Xmmacc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Xmmacc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Xmmacc";
  }
  protected:
  explicit Xmmacc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXmmBytesFieldNumber = 1,
  };
  // bytes xmm_bytes = 1;
  void clear_xmm_bytes();
  const std::string& xmm_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xmm_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xmm_bytes();
  PROTOBUF_NODISCARD std::string* release_xmm_bytes();
  void set_allocated_xmm_bytes(std::string* xmm_bytes);
  private:
  const std::string& _internal_xmm_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xmm_bytes(const std::string& value);
  std::string* _internal_mutable_xmm_bytes();
  public:

  // @@protoc_insertion_point(class_scope:Xmmacc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xmm_bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class Ymmacc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Ymmacc) */ {
 public:
  inline Ymmacc() : Ymmacc(nullptr) {}
  ~Ymmacc() override;
  explicit constexpr Ymmacc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ymmacc(const Ymmacc& from);
  Ymmacc(Ymmacc&& from) noexcept
    : Ymmacc() {
    *this = ::std::move(from);
  }

  inline Ymmacc& operator=(const Ymmacc& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ymmacc& operator=(Ymmacc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ymmacc& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ymmacc* internal_default_instance() {
    return reinterpret_cast<const Ymmacc*>(
               &_Ymmacc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Ymmacc& a, Ymmacc& b) {
    a.Swap(&b);
  }
  inline void Swap(Ymmacc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ymmacc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ymmacc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ymmacc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ymmacc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Ymmacc& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ymmacc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Ymmacc";
  }
  protected:
  explicit Ymmacc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYmmBytesFieldNumber = 1,
  };
  // bytes ymm_bytes = 1;
  void clear_ymm_bytes();
  const std::string& ymm_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ymm_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ymm_bytes();
  PROTOBUF_NODISCARD std::string* release_ymm_bytes();
  void set_allocated_ymm_bytes(std::string* ymm_bytes);
  private:
  const std::string& _internal_ymm_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ymm_bytes(const std::string& value);
  std::string* _internal_mutable_ymm_bytes();
  public:

  // @@protoc_insertion_point(class_scope:Ymmacc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ymm_bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class XstateHdr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:XstateHdr) */ {
 public:
  inline XstateHdr() : XstateHdr(nullptr) {}
  ~XstateHdr() override;
  explicit constexpr XstateHdr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XstateHdr(const XstateHdr& from);
  XstateHdr(XstateHdr&& from) noexcept
    : XstateHdr() {
    *this = ::std::move(from);
  }

  inline XstateHdr& operator=(const XstateHdr& from) {
    CopyFrom(from);
    return *this;
  }
  inline XstateHdr& operator=(XstateHdr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XstateHdr& default_instance() {
    return *internal_default_instance();
  }
  static inline const XstateHdr* internal_default_instance() {
    return reinterpret_cast<const XstateHdr*>(
               &_XstateHdr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(XstateHdr& a, XstateHdr& b) {
    a.Swap(&b);
  }
  inline void Swap(XstateHdr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XstateHdr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XstateHdr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XstateHdr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const XstateHdr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const XstateHdr& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XstateHdr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "XstateHdr";
  }
  protected:
  explicit XstateHdr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXstateBvFieldNumber = 1,
  };
  // uint64 xstate_bv = 1;
  void clear_xstate_bv();
  uint64_t xstate_bv() const;
  void set_xstate_bv(uint64_t value);
  private:
  uint64_t _internal_xstate_bv() const;
  void _internal_set_xstate_bv(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:XstateHdr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t xstate_bv_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class SavefpuXstate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SavefpuXstate) */ {
 public:
  inline SavefpuXstate() : SavefpuXstate(nullptr) {}
  ~SavefpuXstate() override;
  explicit constexpr SavefpuXstate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SavefpuXstate(const SavefpuXstate& from);
  SavefpuXstate(SavefpuXstate&& from) noexcept
    : SavefpuXstate() {
    *this = ::std::move(from);
  }

  inline SavefpuXstate& operator=(const SavefpuXstate& from) {
    CopyFrom(from);
    return *this;
  }
  inline SavefpuXstate& operator=(SavefpuXstate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SavefpuXstate& default_instance() {
    return *internal_default_instance();
  }
  static inline const SavefpuXstate* internal_default_instance() {
    return reinterpret_cast<const SavefpuXstate*>(
               &_SavefpuXstate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(SavefpuXstate& a, SavefpuXstate& b) {
    a.Swap(&b);
  }
  inline void Swap(SavefpuXstate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SavefpuXstate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SavefpuXstate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SavefpuXstate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SavefpuXstate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SavefpuXstate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SavefpuXstate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SavefpuXstate";
  }
  protected:
  explicit SavefpuXstate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSxYmmFieldNumber = 2,
    kSxHdFieldNumber = 1,
  };
  // repeated .Ymmacc sx_ymm = 2;
  int sx_ymm_size() const;
  private:
  int _internal_sx_ymm_size() const;
  public:
  void clear_sx_ymm();
  ::Ymmacc* mutable_sx_ymm(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Ymmacc >*
      mutable_sx_ymm();
  private:
  const ::Ymmacc& _internal_sx_ymm(int index) const;
  ::Ymmacc* _internal_add_sx_ymm();
  public:
  const ::Ymmacc& sx_ymm(int index) const;
  ::Ymmacc* add_sx_ymm();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Ymmacc >&
      sx_ymm() const;

  // .XstateHdr sx_hd = 1;
  bool has_sx_hd() const;
  private:
  bool _internal_has_sx_hd() const;
  public:
  void clear_sx_hd();
  const ::XstateHdr& sx_hd() const;
  PROTOBUF_NODISCARD ::XstateHdr* release_sx_hd();
  ::XstateHdr* mutable_sx_hd();
  void set_allocated_sx_hd(::XstateHdr* sx_hd);
  private:
  const ::XstateHdr& _internal_sx_hd() const;
  ::XstateHdr* _internal_mutable_sx_hd();
  public:
  void unsafe_arena_set_allocated_sx_hd(
      ::XstateHdr* sx_hd);
  ::XstateHdr* unsafe_arena_release_sx_hd();

  // @@protoc_insertion_point(class_scope:SavefpuXstate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Ymmacc > sx_ymm_;
  ::XstateHdr* sx_hd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class Fpregs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Fpregs) */ {
 public:
  inline Fpregs() : Fpregs(nullptr) {}
  ~Fpregs() override;
  explicit constexpr Fpregs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fpregs(const Fpregs& from);
  Fpregs(Fpregs&& from) noexcept
    : Fpregs() {
    *this = ::std::move(from);
  }

  inline Fpregs& operator=(const Fpregs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fpregs& operator=(Fpregs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fpregs& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fpregs* internal_default_instance() {
    return reinterpret_cast<const Fpregs*>(
               &_Fpregs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Fpregs& a, Fpregs& b) {
    a.Swap(&b);
  }
  inline void Swap(Fpregs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fpregs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fpregs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fpregs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fpregs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Fpregs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fpregs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Fpregs";
  }
  protected:
  explicit Fpregs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSvFpFieldNumber = 2,
    kSvXmmFieldNumber = 3,
    kSvnEnvFieldNumber = 1,
    kSvXstateFieldNumber = 5,
  };
  // repeated .Acc sv_fp = 2;
  int sv_fp_size() const;
  private:
  int _internal_sv_fp_size() const;
  public:
  void clear_sv_fp();
  ::Acc* mutable_sv_fp(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Acc >*
      mutable_sv_fp();
  private:
  const ::Acc& _internal_sv_fp(int index) const;
  ::Acc* _internal_add_sv_fp();
  public:
  const ::Acc& sv_fp(int index) const;
  ::Acc* add_sv_fp();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Acc >&
      sv_fp() const;

  // repeated .Xmmacc sv_xmm = 3;
  int sv_xmm_size() const;
  private:
  int _internal_sv_xmm_size() const;
  public:
  void clear_sv_xmm();
  ::Xmmacc* mutable_sv_xmm(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Xmmacc >*
      mutable_sv_xmm();
  private:
  const ::Xmmacc& _internal_sv_xmm(int index) const;
  ::Xmmacc* _internal_add_sv_xmm();
  public:
  const ::Xmmacc& sv_xmm(int index) const;
  ::Xmmacc* add_sv_xmm();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Xmmacc >&
      sv_xmm() const;

  // .Envxmm svn_env = 1;
  bool has_svn_env() const;
  private:
  bool _internal_has_svn_env() const;
  public:
  void clear_svn_env();
  const ::Envxmm& svn_env() const;
  PROTOBUF_NODISCARD ::Envxmm* release_svn_env();
  ::Envxmm* mutable_svn_env();
  void set_allocated_svn_env(::Envxmm* svn_env);
  private:
  const ::Envxmm& _internal_svn_env() const;
  ::Envxmm* _internal_mutable_svn_env();
  public:
  void unsafe_arena_set_allocated_svn_env(
      ::Envxmm* svn_env);
  ::Envxmm* unsafe_arena_release_svn_env();

  // .SavefpuXstate sv_xstate = 5;
  bool has_sv_xstate() const;
  private:
  bool _internal_has_sv_xstate() const;
  public:
  void clear_sv_xstate();
  const ::SavefpuXstate& sv_xstate() const;
  PROTOBUF_NODISCARD ::SavefpuXstate* release_sv_xstate();
  ::SavefpuXstate* mutable_sv_xstate();
  void set_allocated_sv_xstate(::SavefpuXstate* sv_xstate);
  private:
  const ::SavefpuXstate& _internal_sv_xstate() const;
  ::SavefpuXstate* _internal_mutable_sv_xstate();
  public:
  void unsafe_arena_set_allocated_sv_xstate(
      ::SavefpuXstate* sv_xstate);
  ::SavefpuXstate* unsafe_arena_release_sv_xstate();

  // @@protoc_insertion_point(class_scope:Fpregs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Acc > sv_fp_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Xmmacc > sv_xmm_;
  ::Envxmm* svn_env_;
  ::SavefpuXstate* sv_xstate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class RegistersPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegistersPacket) */ {
 public:
  inline RegistersPacket() : RegistersPacket(nullptr) {}
  ~RegistersPacket() override;
  explicit constexpr RegistersPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistersPacket(const RegistersPacket& from);
  RegistersPacket(RegistersPacket&& from) noexcept
    : RegistersPacket() {
    *this = ::std::move(from);
  }

  inline RegistersPacket& operator=(const RegistersPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistersPacket& operator=(RegistersPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistersPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegistersPacket* internal_default_instance() {
    return reinterpret_cast<const RegistersPacket*>(
               &_RegistersPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(RegistersPacket& a, RegistersPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistersPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistersPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistersPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistersPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistersPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegistersPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistersPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegistersPacket";
  }
  protected:
  explicit RegistersPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kR15FieldNumber = 1,
    kR14FieldNumber = 2,
    kR13FieldNumber = 3,
    kR12FieldNumber = 4,
    kR11FieldNumber = 5,
    kR10FieldNumber = 6,
    kR9FieldNumber = 7,
    kR8FieldNumber = 8,
    kRdiFieldNumber = 9,
    kRsiFieldNumber = 10,
    kRbpFieldNumber = 11,
    kRbxFieldNumber = 12,
    kRdxFieldNumber = 13,
    kRcxFieldNumber = 14,
    kRaxFieldNumber = 15,
    kTrapnoFieldNumber = 16,
    kFsFieldNumber = 17,
    kErrFieldNumber = 19,
    kGsFieldNumber = 18,
    kEsFieldNumber = 20,
    kRipFieldNumber = 22,
    kCsFieldNumber = 23,
    kRflagsFieldNumber = 24,
    kRspFieldNumber = 25,
    kSsFieldNumber = 26,
    kDsFieldNumber = 21,
  };
  // uint64 r15 = 1;
  void clear_r15();
  uint64_t r15() const;
  void set_r15(uint64_t value);
  private:
  uint64_t _internal_r15() const;
  void _internal_set_r15(uint64_t value);
  public:

  // uint64 r14 = 2;
  void clear_r14();
  uint64_t r14() const;
  void set_r14(uint64_t value);
  private:
  uint64_t _internal_r14() const;
  void _internal_set_r14(uint64_t value);
  public:

  // uint64 r13 = 3;
  void clear_r13();
  uint64_t r13() const;
  void set_r13(uint64_t value);
  private:
  uint64_t _internal_r13() const;
  void _internal_set_r13(uint64_t value);
  public:

  // uint64 r12 = 4;
  void clear_r12();
  uint64_t r12() const;
  void set_r12(uint64_t value);
  private:
  uint64_t _internal_r12() const;
  void _internal_set_r12(uint64_t value);
  public:

  // uint64 r11 = 5;
  void clear_r11();
  uint64_t r11() const;
  void set_r11(uint64_t value);
  private:
  uint64_t _internal_r11() const;
  void _internal_set_r11(uint64_t value);
  public:

  // uint64 r10 = 6;
  void clear_r10();
  uint64_t r10() const;
  void set_r10(uint64_t value);
  private:
  uint64_t _internal_r10() const;
  void _internal_set_r10(uint64_t value);
  public:

  // uint64 r9 = 7;
  void clear_r9();
  uint64_t r9() const;
  void set_r9(uint64_t value);
  private:
  uint64_t _internal_r9() const;
  void _internal_set_r9(uint64_t value);
  public:

  // uint64 r8 = 8;
  void clear_r8();
  uint64_t r8() const;
  void set_r8(uint64_t value);
  private:
  uint64_t _internal_r8() const;
  void _internal_set_r8(uint64_t value);
  public:

  // uint64 rdi = 9;
  void clear_rdi();
  uint64_t rdi() const;
  void set_rdi(uint64_t value);
  private:
  uint64_t _internal_rdi() const;
  void _internal_set_rdi(uint64_t value);
  public:

  // uint64 rsi = 10;
  void clear_rsi();
  uint64_t rsi() const;
  void set_rsi(uint64_t value);
  private:
  uint64_t _internal_rsi() const;
  void _internal_set_rsi(uint64_t value);
  public:

  // uint64 rbp = 11;
  void clear_rbp();
  uint64_t rbp() const;
  void set_rbp(uint64_t value);
  private:
  uint64_t _internal_rbp() const;
  void _internal_set_rbp(uint64_t value);
  public:

  // uint64 rbx = 12;
  void clear_rbx();
  uint64_t rbx() const;
  void set_rbx(uint64_t value);
  private:
  uint64_t _internal_rbx() const;
  void _internal_set_rbx(uint64_t value);
  public:

  // uint64 rdx = 13;
  void clear_rdx();
  uint64_t rdx() const;
  void set_rdx(uint64_t value);
  private:
  uint64_t _internal_rdx() const;
  void _internal_set_rdx(uint64_t value);
  public:

  // uint64 rcx = 14;
  void clear_rcx();
  uint64_t rcx() const;
  void set_rcx(uint64_t value);
  private:
  uint64_t _internal_rcx() const;
  void _internal_set_rcx(uint64_t value);
  public:

  // uint64 rax = 15;
  void clear_rax();
  uint64_t rax() const;
  void set_rax(uint64_t value);
  private:
  uint64_t _internal_rax() const;
  void _internal_set_rax(uint64_t value);
  public:

  // uint32 trapno = 16;
  void clear_trapno();
  uint32_t trapno() const;
  void set_trapno(uint32_t value);
  private:
  uint32_t _internal_trapno() const;
  void _internal_set_trapno(uint32_t value);
  public:

  // uint32 fs = 17;
  void clear_fs();
  uint32_t fs() const;
  void set_fs(uint32_t value);
  private:
  uint32_t _internal_fs() const;
  void _internal_set_fs(uint32_t value);
  public:

  // uint64 err = 19;
  void clear_err();
  uint64_t err() const;
  void set_err(uint64_t value);
  private:
  uint64_t _internal_err() const;
  void _internal_set_err(uint64_t value);
  public:

  // uint32 gs = 18;
  void clear_gs();
  uint32_t gs() const;
  void set_gs(uint32_t value);
  private:
  uint32_t _internal_gs() const;
  void _internal_set_gs(uint32_t value);
  public:

  // uint32 es = 20;
  void clear_es();
  uint32_t es() const;
  void set_es(uint32_t value);
  private:
  uint32_t _internal_es() const;
  void _internal_set_es(uint32_t value);
  public:

  // uint64 rip = 22;
  void clear_rip();
  uint64_t rip() const;
  void set_rip(uint64_t value);
  private:
  uint64_t _internal_rip() const;
  void _internal_set_rip(uint64_t value);
  public:

  // uint64 cs = 23;
  void clear_cs();
  uint64_t cs() const;
  void set_cs(uint64_t value);
  private:
  uint64_t _internal_cs() const;
  void _internal_set_cs(uint64_t value);
  public:

  // uint64 rflags = 24;
  void clear_rflags();
  uint64_t rflags() const;
  void set_rflags(uint64_t value);
  private:
  uint64_t _internal_rflags() const;
  void _internal_set_rflags(uint64_t value);
  public:

  // uint64 rsp = 25;
  void clear_rsp();
  uint64_t rsp() const;
  void set_rsp(uint64_t value);
  private:
  uint64_t _internal_rsp() const;
  void _internal_set_rsp(uint64_t value);
  public:

  // uint64 ss = 26;
  void clear_ss();
  uint64_t ss() const;
  void set_ss(uint64_t value);
  private:
  uint64_t _internal_ss() const;
  void _internal_set_ss(uint64_t value);
  public:

  // uint32 ds = 21;
  void clear_ds();
  uint32_t ds() const;
  void set_ds(uint32_t value);
  private:
  uint32_t _internal_ds() const;
  void _internal_set_ds(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RegistersPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t r15_;
  uint64_t r14_;
  uint64_t r13_;
  uint64_t r12_;
  uint64_t r11_;
  uint64_t r10_;
  uint64_t r9_;
  uint64_t r8_;
  uint64_t rdi_;
  uint64_t rsi_;
  uint64_t rbp_;
  uint64_t rbx_;
  uint64_t rdx_;
  uint64_t rcx_;
  uint64_t rax_;
  uint32_t trapno_;
  uint32_t fs_;
  uint64_t err_;
  uint32_t gs_;
  uint32_t es_;
  uint64_t rip_;
  uint64_t cs_;
  uint64_t rflags_;
  uint64_t rsp_;
  uint64_t ss_;
  uint32_t ds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class DebuggerInterruptPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DebuggerInterruptPacket) */ {
 public:
  inline DebuggerInterruptPacket() : DebuggerInterruptPacket(nullptr) {}
  ~DebuggerInterruptPacket() override;
  explicit constexpr DebuggerInterruptPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebuggerInterruptPacket(const DebuggerInterruptPacket& from);
  DebuggerInterruptPacket(DebuggerInterruptPacket&& from) noexcept
    : DebuggerInterruptPacket() {
    *this = ::std::move(from);
  }

  inline DebuggerInterruptPacket& operator=(const DebuggerInterruptPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebuggerInterruptPacket& operator=(DebuggerInterruptPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebuggerInterruptPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebuggerInterruptPacket* internal_default_instance() {
    return reinterpret_cast<const DebuggerInterruptPacket*>(
               &_DebuggerInterruptPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(DebuggerInterruptPacket& a, DebuggerInterruptPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(DebuggerInterruptPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebuggerInterruptPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebuggerInterruptPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebuggerInterruptPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebuggerInterruptPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DebuggerInterruptPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebuggerInterruptPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DebuggerInterruptPacket";
  }
  protected:
  explicit DebuggerInterruptPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kRegistersFieldNumber = 4,
    kFloatRegistersFieldNumber = 5,
    kThreadIdFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string Name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .RegistersPacket Registers = 4;
  bool has_registers() const;
  private:
  bool _internal_has_registers() const;
  public:
  void clear_registers();
  const ::RegistersPacket& registers() const;
  PROTOBUF_NODISCARD ::RegistersPacket* release_registers();
  ::RegistersPacket* mutable_registers();
  void set_allocated_registers(::RegistersPacket* registers);
  private:
  const ::RegistersPacket& _internal_registers() const;
  ::RegistersPacket* _internal_mutable_registers();
  public:
  void unsafe_arena_set_allocated_registers(
      ::RegistersPacket* registers);
  ::RegistersPacket* unsafe_arena_release_registers();

  // .Fpregs FloatRegisters = 5;
  bool has_floatregisters() const;
  private:
  bool _internal_has_floatregisters() const;
  public:
  void clear_floatregisters();
  const ::Fpregs& floatregisters() const;
  PROTOBUF_NODISCARD ::Fpregs* release_floatregisters();
  ::Fpregs* mutable_floatregisters();
  void set_allocated_floatregisters(::Fpregs* floatregisters);
  private:
  const ::Fpregs& _internal_floatregisters() const;
  ::Fpregs* _internal_mutable_floatregisters();
  public:
  void unsafe_arena_set_allocated_floatregisters(
      ::Fpregs* floatregisters);
  ::Fpregs* unsafe_arena_release_floatregisters();

  // uint32 ThreadId = 1;
  void clear_threadid();
  uint32_t threadid() const;
  void set_threadid(uint32_t value);
  private:
  uint32_t _internal_threadid() const;
  void _internal_set_threadid(uint32_t value);
  public:

  // uint32 Status = 2;
  void clear_status();
  uint32_t status() const;
  void set_status(uint32_t value);
  private:
  uint32_t _internal_status() const;
  void _internal_set_status(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:DebuggerInterruptPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::RegistersPacket* registers_;
  ::Fpregs* floatregisters_;
  uint32_t threadid_;
  uint32_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InitialPacket

// int32 PacketVersion = 1;
inline void InitialPacket::clear_packetversion() {
  packetversion_ = 0;
}
inline int32_t InitialPacket::_internal_packetversion() const {
  return packetversion_;
}
inline int32_t InitialPacket::packetversion() const {
  // @@protoc_insertion_point(field_get:InitialPacket.PacketVersion)
  return _internal_packetversion();
}
inline void InitialPacket::_internal_set_packetversion(int32_t value) {
  
  packetversion_ = value;
}
inline void InitialPacket::set_packetversion(int32_t value) {
  _internal_set_packetversion(value);
  // @@protoc_insertion_point(field_set:InitialPacket.PacketVersion)
}

// int32 Command = 2;
inline void InitialPacket::clear_command() {
  command_ = 0;
}
inline int32_t InitialPacket::_internal_command() const {
  return command_;
}
inline int32_t InitialPacket::command() const {
  // @@protoc_insertion_point(field_get:InitialPacket.Command)
  return _internal_command();
}
inline void InitialPacket::_internal_set_command(int32_t value) {
  
  command_ = value;
}
inline void InitialPacket::set_command(int32_t value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:InitialPacket.Command)
}

// -------------------------------------------------------------------

// ResultState

// bool Succeeded = 1;
inline void ResultState::clear_succeeded() {
  succeeded_ = false;
}
inline bool ResultState::_internal_succeeded() const {
  return succeeded_;
}
inline bool ResultState::succeeded() const {
  // @@protoc_insertion_point(field_get:ResultState.Succeeded)
  return _internal_succeeded();
}
inline void ResultState::_internal_set_succeeded(bool value) {
  
  succeeded_ = value;
}
inline void ResultState::set_succeeded(bool value) {
  _internal_set_succeeded(value);
  // @@protoc_insertion_point(field_set:ResultState.Succeeded)
}

// string ErrorMessage = 2;
inline void ResultState::clear_errormessage() {
  errormessage_.ClearToEmpty();
}
inline const std::string& ResultState::errormessage() const {
  // @@protoc_insertion_point(field_get:ResultState.ErrorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultState::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResultState.ErrorMessage)
}
inline std::string* ResultState::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:ResultState.ErrorMessage)
  return _s;
}
inline const std::string& ResultState::_internal_errormessage() const {
  return errormessage_.Get();
}
inline void ResultState::_internal_set_errormessage(const std::string& value) {
  
  errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResultState::_internal_mutable_errormessage() {
  
  return errormessage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResultState::release_errormessage() {
  // @@protoc_insertion_point(field_release:ResultState.ErrorMessage)
  return errormessage_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResultState::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  errormessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormessage,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (errormessage_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    errormessage_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResultState.ErrorMessage)
}

// -------------------------------------------------------------------

// AppInfoPacket

// string TitleId = 1;
inline void AppInfoPacket::clear_titleid() {
  titleid_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::titleid() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.TitleId)
  return _internal_titleid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_titleid(ArgT0&& arg0, ArgT... args) {
 
 titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.TitleId)
}
inline std::string* AppInfoPacket::mutable_titleid() {
  std::string* _s = _internal_mutable_titleid();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.TitleId)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_titleid() const {
  return titleid_.Get();
}
inline void AppInfoPacket::_internal_set_titleid(const std::string& value) {
  
  titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_titleid() {
  
  return titleid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_titleid() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.TitleId)
  return titleid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_titleid(std::string* titleid) {
  if (titleid != nullptr) {
    
  } else {
    
  }
  titleid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), titleid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (titleid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    titleid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.TitleId)
}

// string ContentId = 2;
inline void AppInfoPacket::clear_contentid() {
  contentid_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::contentid() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.ContentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 contentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.ContentId)
}
inline std::string* AppInfoPacket::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.ContentId)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_contentid() const {
  return contentid_.Get();
}
inline void AppInfoPacket::_internal_set_contentid(const std::string& value) {
  
  contentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_contentid() {
  
  return contentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_contentid() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.ContentId)
  return contentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  contentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contentid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contentid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contentid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.ContentId)
}

// string TitleName = 3;
inline void AppInfoPacket::clear_titlename() {
  titlename_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::titlename() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.TitleName)
  return _internal_titlename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_titlename(ArgT0&& arg0, ArgT... args) {
 
 titlename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.TitleName)
}
inline std::string* AppInfoPacket::mutable_titlename() {
  std::string* _s = _internal_mutable_titlename();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.TitleName)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_titlename() const {
  return titlename_.Get();
}
inline void AppInfoPacket::_internal_set_titlename(const std::string& value) {
  
  titlename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_titlename() {
  
  return titlename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_titlename() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.TitleName)
  return titlename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_titlename(std::string* titlename) {
  if (titlename != nullptr) {
    
  } else {
    
  }
  titlename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), titlename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (titlename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    titlename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.TitleName)
}

// string MetaDataPath = 4;
inline void AppInfoPacket::clear_metadatapath() {
  metadatapath_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::metadatapath() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.MetaDataPath)
  return _internal_metadatapath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_metadatapath(ArgT0&& arg0, ArgT... args) {
 
 metadatapath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.MetaDataPath)
}
inline std::string* AppInfoPacket::mutable_metadatapath() {
  std::string* _s = _internal_mutable_metadatapath();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.MetaDataPath)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_metadatapath() const {
  return metadatapath_.Get();
}
inline void AppInfoPacket::_internal_set_metadatapath(const std::string& value) {
  
  metadatapath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_metadatapath() {
  
  return metadatapath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_metadatapath() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.MetaDataPath)
  return metadatapath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_metadatapath(std::string* metadatapath) {
  if (metadatapath != nullptr) {
    
  } else {
    
  }
  metadatapath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metadatapath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (metadatapath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    metadatapath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.MetaDataPath)
}

// string LastAccessTime = 5;
inline void AppInfoPacket::clear_lastaccesstime() {
  lastaccesstime_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::lastaccesstime() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.LastAccessTime)
  return _internal_lastaccesstime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_lastaccesstime(ArgT0&& arg0, ArgT... args) {
 
 lastaccesstime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.LastAccessTime)
}
inline std::string* AppInfoPacket::mutable_lastaccesstime() {
  std::string* _s = _internal_mutable_lastaccesstime();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.LastAccessTime)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_lastaccesstime() const {
  return lastaccesstime_.Get();
}
inline void AppInfoPacket::_internal_set_lastaccesstime(const std::string& value) {
  
  lastaccesstime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_lastaccesstime() {
  
  return lastaccesstime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_lastaccesstime() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.LastAccessTime)
  return lastaccesstime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_lastaccesstime(std::string* lastaccesstime) {
  if (lastaccesstime != nullptr) {
    
  } else {
    
  }
  lastaccesstime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lastaccesstime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lastaccesstime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lastaccesstime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.LastAccessTime)
}

// bool IsVisible = 6;
inline void AppInfoPacket::clear_isvisible() {
  isvisible_ = false;
}
inline bool AppInfoPacket::_internal_isvisible() const {
  return isvisible_;
}
inline bool AppInfoPacket::isvisible() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.IsVisible)
  return _internal_isvisible();
}
inline void AppInfoPacket::_internal_set_isvisible(bool value) {
  
  isvisible_ = value;
}
inline void AppInfoPacket::set_isvisible(bool value) {
  _internal_set_isvisible(value);
  // @@protoc_insertion_point(field_set:AppInfoPacket.IsVisible)
}

// int32 SortPriority = 7;
inline void AppInfoPacket::clear_sortpriority() {
  sortpriority_ = 0;
}
inline int32_t AppInfoPacket::_internal_sortpriority() const {
  return sortpriority_;
}
inline int32_t AppInfoPacket::sortpriority() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.SortPriority)
  return _internal_sortpriority();
}
inline void AppInfoPacket::_internal_set_sortpriority(int32_t value) {
  
  sortpriority_ = value;
}
inline void AppInfoPacket::set_sortpriority(int32_t value) {
  _internal_set_sortpriority(value);
  // @@protoc_insertion_point(field_set:AppInfoPacket.SortPriority)
}

// int32 DispLocation = 8;
inline void AppInfoPacket::clear_displocation() {
  displocation_ = 0;
}
inline int32_t AppInfoPacket::_internal_displocation() const {
  return displocation_;
}
inline int32_t AppInfoPacket::displocation() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.DispLocation)
  return _internal_displocation();
}
inline void AppInfoPacket::_internal_set_displocation(int32_t value) {
  
  displocation_ = value;
}
inline void AppInfoPacket::set_displocation(int32_t value) {
  _internal_set_displocation(value);
  // @@protoc_insertion_point(field_set:AppInfoPacket.DispLocation)
}

// string Category = 9;
inline void AppInfoPacket::clear_category() {
  category_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::category() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.Category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_category(ArgT0&& arg0, ArgT... args) {
 
 category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.Category)
}
inline std::string* AppInfoPacket::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.Category)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_category() const {
  return category_.Get();
}
inline void AppInfoPacket::_internal_set_category(const std::string& value) {
  
  category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_category() {
  
  return category_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_category() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.Category)
  return category_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  category_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), category,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (category_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    category_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.Category)
}

// int32 ContentSize = 10;
inline void AppInfoPacket::clear_contentsize() {
  contentsize_ = 0;
}
inline int32_t AppInfoPacket::_internal_contentsize() const {
  return contentsize_;
}
inline int32_t AppInfoPacket::contentsize() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.ContentSize)
  return _internal_contentsize();
}
inline void AppInfoPacket::_internal_set_contentsize(int32_t value) {
  
  contentsize_ = value;
}
inline void AppInfoPacket::set_contentsize(int32_t value) {
  _internal_set_contentsize(value);
  // @@protoc_insertion_point(field_set:AppInfoPacket.ContentSize)
}

// string InstallDate = 11;
inline void AppInfoPacket::clear_installdate() {
  installdate_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::installdate() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.InstallDate)
  return _internal_installdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_installdate(ArgT0&& arg0, ArgT... args) {
 
 installdate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.InstallDate)
}
inline std::string* AppInfoPacket::mutable_installdate() {
  std::string* _s = _internal_mutable_installdate();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.InstallDate)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_installdate() const {
  return installdate_.Get();
}
inline void AppInfoPacket::_internal_set_installdate(const std::string& value) {
  
  installdate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_installdate() {
  
  return installdate_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_installdate() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.InstallDate)
  return installdate_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_installdate(std::string* installdate) {
  if (installdate != nullptr) {
    
  } else {
    
  }
  installdate_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), installdate,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (installdate_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    installdate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.InstallDate)
}

// string UICategory = 12;
inline void AppInfoPacket::clear_uicategory() {
  uicategory_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::uicategory() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.UICategory)
  return _internal_uicategory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_uicategory(ArgT0&& arg0, ArgT... args) {
 
 uicategory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.UICategory)
}
inline std::string* AppInfoPacket::mutable_uicategory() {
  std::string* _s = _internal_mutable_uicategory();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.UICategory)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_uicategory() const {
  return uicategory_.Get();
}
inline void AppInfoPacket::_internal_set_uicategory(const std::string& value) {
  
  uicategory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_uicategory() {
  
  return uicategory_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_uicategory() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.UICategory)
  return uicategory_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_uicategory(std::string* uicategory) {
  if (uicategory != nullptr) {
    
  } else {
    
  }
  uicategory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uicategory,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uicategory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uicategory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.UICategory)
}

// -------------------------------------------------------------------

// AppInfoListPacket

// repeated .AppInfoPacket Apps = 1;
inline int AppInfoListPacket::_internal_apps_size() const {
  return apps_.size();
}
inline int AppInfoListPacket::apps_size() const {
  return _internal_apps_size();
}
inline void AppInfoListPacket::clear_apps() {
  apps_.Clear();
}
inline ::AppInfoPacket* AppInfoListPacket::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:AppInfoListPacket.Apps)
  return apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AppInfoPacket >*
AppInfoListPacket::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:AppInfoListPacket.Apps)
  return &apps_;
}
inline const ::AppInfoPacket& AppInfoListPacket::_internal_apps(int index) const {
  return apps_.Get(index);
}
inline const ::AppInfoPacket& AppInfoListPacket::apps(int index) const {
  // @@protoc_insertion_point(field_get:AppInfoListPacket.Apps)
  return _internal_apps(index);
}
inline ::AppInfoPacket* AppInfoListPacket::_internal_add_apps() {
  return apps_.Add();
}
inline ::AppInfoPacket* AppInfoListPacket::add_apps() {
  ::AppInfoPacket* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:AppInfoListPacket.Apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AppInfoPacket >&
AppInfoListPacket::apps() const {
  // @@protoc_insertion_point(field_list:AppInfoListPacket.Apps)
  return apps_;
}

// -------------------------------------------------------------------

// AppPacket

// string TitleId = 1;
inline void AppPacket::clear_titleid() {
  titleid_.ClearToEmpty();
}
inline const std::string& AppPacket::titleid() const {
  // @@protoc_insertion_point(field_get:AppPacket.TitleId)
  return _internal_titleid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppPacket::set_titleid(ArgT0&& arg0, ArgT... args) {
 
 titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppPacket.TitleId)
}
inline std::string* AppPacket::mutable_titleid() {
  std::string* _s = _internal_mutable_titleid();
  // @@protoc_insertion_point(field_mutable:AppPacket.TitleId)
  return _s;
}
inline const std::string& AppPacket::_internal_titleid() const {
  return titleid_.Get();
}
inline void AppPacket::_internal_set_titleid(const std::string& value) {
  
  titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppPacket::_internal_mutable_titleid() {
  
  return titleid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppPacket::release_titleid() {
  // @@protoc_insertion_point(field_release:AppPacket.TitleId)
  return titleid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppPacket::set_allocated_titleid(std::string* titleid) {
  if (titleid != nullptr) {
    
  } else {
    
  }
  titleid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), titleid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (titleid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    titleid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppPacket.TitleId)
}

// -------------------------------------------------------------------

// RWPacket

// uint64 Address = 1;
inline void RWPacket::clear_address() {
  address_ = uint64_t{0u};
}
inline uint64_t RWPacket::_internal_address() const {
  return address_;
}
inline uint64_t RWPacket::address() const {
  // @@protoc_insertion_point(field_get:RWPacket.Address)
  return _internal_address();
}
inline void RWPacket::_internal_set_address(uint64_t value) {
  
  address_ = value;
}
inline void RWPacket::set_address(uint64_t value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:RWPacket.Address)
}

// uint64 Length = 2;
inline void RWPacket::clear_length() {
  length_ = uint64_t{0u};
}
inline uint64_t RWPacket::_internal_length() const {
  return length_;
}
inline uint64_t RWPacket::length() const {
  // @@protoc_insertion_point(field_get:RWPacket.Length)
  return _internal_length();
}
inline void RWPacket::_internal_set_length(uint64_t value) {
  
  length_ = value;
}
inline void RWPacket::set_length(uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:RWPacket.Length)
}

// -------------------------------------------------------------------

// SPRXPacket

// string Path = 1;
inline void SPRXPacket::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& SPRXPacket::path() const {
  // @@protoc_insertion_point(field_get:SPRXPacket.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SPRXPacket::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SPRXPacket.Path)
}
inline std::string* SPRXPacket::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SPRXPacket.Path)
  return _s;
}
inline const std::string& SPRXPacket::_internal_path() const {
  return path_.Get();
}
inline void SPRXPacket::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SPRXPacket::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SPRXPacket::release_path() {
  // @@protoc_insertion_point(field_release:SPRXPacket.Path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SPRXPacket::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SPRXPacket.Path)
}

// int32 Handle = 2;
inline void SPRXPacket::clear_handle() {
  handle_ = 0;
}
inline int32_t SPRXPacket::_internal_handle() const {
  return handle_;
}
inline int32_t SPRXPacket::handle() const {
  // @@protoc_insertion_point(field_get:SPRXPacket.Handle)
  return _internal_handle();
}
inline void SPRXPacket::_internal_set_handle(int32_t value) {
  
  handle_ = value;
}
inline void SPRXPacket::set_handle(int32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:SPRXPacket.Handle)
}

// -------------------------------------------------------------------

// MemoryInfo

// int32 Used = 1;
inline void MemoryInfo::clear_used() {
  used_ = 0;
}
inline int32_t MemoryInfo::_internal_used() const {
  return used_;
}
inline int32_t MemoryInfo::used() const {
  // @@protoc_insertion_point(field_get:MemoryInfo.Used)
  return _internal_used();
}
inline void MemoryInfo::_internal_set_used(int32_t value) {
  
  used_ = value;
}
inline void MemoryInfo::set_used(int32_t value) {
  _internal_set_used(value);
  // @@protoc_insertion_point(field_set:MemoryInfo.Used)
}

// int32 Free = 2;
inline void MemoryInfo::clear_free() {
  free_ = 0;
}
inline int32_t MemoryInfo::_internal_free() const {
  return free_;
}
inline int32_t MemoryInfo::free() const {
  // @@protoc_insertion_point(field_get:MemoryInfo.Free)
  return _internal_free();
}
inline void MemoryInfo::_internal_set_free(int32_t value) {
  
  free_ = value;
}
inline void MemoryInfo::set_free(int32_t value) {
  _internal_set_free(value);
  // @@protoc_insertion_point(field_set:MemoryInfo.Free)
}

// int32 Total = 3;
inline void MemoryInfo::clear_total() {
  total_ = 0;
}
inline int32_t MemoryInfo::_internal_total() const {
  return total_;
}
inline int32_t MemoryInfo::total() const {
  // @@protoc_insertion_point(field_get:MemoryInfo.Total)
  return _internal_total();
}
inline void MemoryInfo::_internal_set_total(int32_t value) {
  
  total_ = value;
}
inline void MemoryInfo::set_total(int32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:MemoryInfo.Total)
}

// float Percentage = 4;
inline void MemoryInfo::clear_percentage() {
  percentage_ = 0;
}
inline float MemoryInfo::_internal_percentage() const {
  return percentage_;
}
inline float MemoryInfo::percentage() const {
  // @@protoc_insertion_point(field_get:MemoryInfo.Percentage)
  return _internal_percentage();
}
inline void MemoryInfo::_internal_set_percentage(float value) {
  
  percentage_ = value;
}
inline void MemoryInfo::set_percentage(float value) {
  _internal_set_percentage(value);
  // @@protoc_insertion_point(field_set:MemoryInfo.Percentage)
}

// -------------------------------------------------------------------

// CurrentBigApp

// int32 Pid = 1;
inline void CurrentBigApp::clear_pid() {
  pid_ = 0;
}
inline int32_t CurrentBigApp::_internal_pid() const {
  return pid_;
}
inline int32_t CurrentBigApp::pid() const {
  // @@protoc_insertion_point(field_get:CurrentBigApp.Pid)
  return _internal_pid();
}
inline void CurrentBigApp::_internal_set_pid(int32_t value) {
  
  pid_ = value;
}
inline void CurrentBigApp::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:CurrentBigApp.Pid)
}

// string Name = 2;
inline void CurrentBigApp::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CurrentBigApp::name() const {
  // @@protoc_insertion_point(field_get:CurrentBigApp.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrentBigApp::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CurrentBigApp.Name)
}
inline std::string* CurrentBigApp::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CurrentBigApp.Name)
  return _s;
}
inline const std::string& CurrentBigApp::_internal_name() const {
  return name_.Get();
}
inline void CurrentBigApp::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrentBigApp::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrentBigApp::release_name() {
  // @@protoc_insertion_point(field_release:CurrentBigApp.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CurrentBigApp::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CurrentBigApp.Name)
}

// string TitleId = 3;
inline void CurrentBigApp::clear_titleid() {
  titleid_.ClearToEmpty();
}
inline const std::string& CurrentBigApp::titleid() const {
  // @@protoc_insertion_point(field_get:CurrentBigApp.TitleId)
  return _internal_titleid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrentBigApp::set_titleid(ArgT0&& arg0, ArgT... args) {
 
 titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CurrentBigApp.TitleId)
}
inline std::string* CurrentBigApp::mutable_titleid() {
  std::string* _s = _internal_mutable_titleid();
  // @@protoc_insertion_point(field_mutable:CurrentBigApp.TitleId)
  return _s;
}
inline const std::string& CurrentBigApp::_internal_titleid() const {
  return titleid_.Get();
}
inline void CurrentBigApp::_internal_set_titleid(const std::string& value) {
  
  titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrentBigApp::_internal_mutable_titleid() {
  
  return titleid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrentBigApp::release_titleid() {
  // @@protoc_insertion_point(field_release:CurrentBigApp.TitleId)
  return titleid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CurrentBigApp::set_allocated_titleid(std::string* titleid) {
  if (titleid != nullptr) {
    
  } else {
    
  }
  titleid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), titleid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (titleid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    titleid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CurrentBigApp.TitleId)
}

// -------------------------------------------------------------------

// TargetInfoPacket

// int32 SDKVersion = 1;
inline void TargetInfoPacket::clear_sdkversion() {
  sdkversion_ = 0;
}
inline int32_t TargetInfoPacket::_internal_sdkversion() const {
  return sdkversion_;
}
inline int32_t TargetInfoPacket::sdkversion() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.SDKVersion)
  return _internal_sdkversion();
}
inline void TargetInfoPacket::_internal_set_sdkversion(int32_t value) {
  
  sdkversion_ = value;
}
inline void TargetInfoPacket::set_sdkversion(int32_t value) {
  _internal_set_sdkversion(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.SDKVersion)
}

// int32 SoftwareVersion = 2;
inline void TargetInfoPacket::clear_softwareversion() {
  softwareversion_ = 0;
}
inline int32_t TargetInfoPacket::_internal_softwareversion() const {
  return softwareversion_;
}
inline int32_t TargetInfoPacket::softwareversion() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.SoftwareVersion)
  return _internal_softwareversion();
}
inline void TargetInfoPacket::_internal_set_softwareversion(int32_t value) {
  
  softwareversion_ = value;
}
inline void TargetInfoPacket::set_softwareversion(int32_t value) {
  _internal_set_softwareversion(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.SoftwareVersion)
}

// int32 FactorySoftwareVersion = 3;
inline void TargetInfoPacket::clear_factorysoftwareversion() {
  factorysoftwareversion_ = 0;
}
inline int32_t TargetInfoPacket::_internal_factorysoftwareversion() const {
  return factorysoftwareversion_;
}
inline int32_t TargetInfoPacket::factorysoftwareversion() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.FactorySoftwareVersion)
  return _internal_factorysoftwareversion();
}
inline void TargetInfoPacket::_internal_set_factorysoftwareversion(int32_t value) {
  
  factorysoftwareversion_ = value;
}
inline void TargetInfoPacket::set_factorysoftwareversion(int32_t value) {
  _internal_set_factorysoftwareversion(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.FactorySoftwareVersion)
}

// .CurrentBigApp BigApp = 4;
inline bool TargetInfoPacket::_internal_has_bigapp() const {
  return this != internal_default_instance() && bigapp_ != nullptr;
}
inline bool TargetInfoPacket::has_bigapp() const {
  return _internal_has_bigapp();
}
inline void TargetInfoPacket::clear_bigapp() {
  if (GetArenaForAllocation() == nullptr && bigapp_ != nullptr) {
    delete bigapp_;
  }
  bigapp_ = nullptr;
}
inline const ::CurrentBigApp& TargetInfoPacket::_internal_bigapp() const {
  const ::CurrentBigApp* p = bigapp_;
  return p != nullptr ? *p : reinterpret_cast<const ::CurrentBigApp&>(
      ::_CurrentBigApp_default_instance_);
}
inline const ::CurrentBigApp& TargetInfoPacket::bigapp() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.BigApp)
  return _internal_bigapp();
}
inline void TargetInfoPacket::unsafe_arena_set_allocated_bigapp(
    ::CurrentBigApp* bigapp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bigapp_);
  }
  bigapp_ = bigapp;
  if (bigapp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TargetInfoPacket.BigApp)
}
inline ::CurrentBigApp* TargetInfoPacket::release_bigapp() {
  
  ::CurrentBigApp* temp = bigapp_;
  bigapp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CurrentBigApp* TargetInfoPacket::unsafe_arena_release_bigapp() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.BigApp)
  
  ::CurrentBigApp* temp = bigapp_;
  bigapp_ = nullptr;
  return temp;
}
inline ::CurrentBigApp* TargetInfoPacket::_internal_mutable_bigapp() {
  
  if (bigapp_ == nullptr) {
    auto* p = CreateMaybeMessage<::CurrentBigApp>(GetArenaForAllocation());
    bigapp_ = p;
  }
  return bigapp_;
}
inline ::CurrentBigApp* TargetInfoPacket::mutable_bigapp() {
  ::CurrentBigApp* _msg = _internal_mutable_bigapp();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.BigApp)
  return _msg;
}
inline void TargetInfoPacket::set_allocated_bigapp(::CurrentBigApp* bigapp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bigapp_;
  }
  if (bigapp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CurrentBigApp>::GetOwningArena(bigapp);
    if (message_arena != submessage_arena) {
      bigapp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bigapp, submessage_arena);
    }
    
  } else {
    
  }
  bigapp_ = bigapp;
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.BigApp)
}

// string ConsoleName = 5;
inline void TargetInfoPacket::clear_consolename() {
  consolename_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::consolename() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.ConsoleName)
  return _internal_consolename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_consolename(ArgT0&& arg0, ArgT... args) {
 
 consolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.ConsoleName)
}
inline std::string* TargetInfoPacket::mutable_consolename() {
  std::string* _s = _internal_mutable_consolename();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.ConsoleName)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_consolename() const {
  return consolename_.Get();
}
inline void TargetInfoPacket::_internal_set_consolename(const std::string& value) {
  
  consolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_consolename() {
  
  return consolename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_consolename() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.ConsoleName)
  return consolename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_consolename(std::string* consolename) {
  if (consolename != nullptr) {
    
  } else {
    
  }
  consolename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), consolename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (consolename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    consolename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.ConsoleName)
}

// string MotherboardSerial = 6;
inline void TargetInfoPacket::clear_motherboardserial() {
  motherboardserial_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::motherboardserial() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.MotherboardSerial)
  return _internal_motherboardserial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_motherboardserial(ArgT0&& arg0, ArgT... args) {
 
 motherboardserial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.MotherboardSerial)
}
inline std::string* TargetInfoPacket::mutable_motherboardserial() {
  std::string* _s = _internal_mutable_motherboardserial();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.MotherboardSerial)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_motherboardserial() const {
  return motherboardserial_.Get();
}
inline void TargetInfoPacket::_internal_set_motherboardserial(const std::string& value) {
  
  motherboardserial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_motherboardserial() {
  
  return motherboardserial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_motherboardserial() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.MotherboardSerial)
  return motherboardserial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_motherboardserial(std::string* motherboardserial) {
  if (motherboardserial != nullptr) {
    
  } else {
    
  }
  motherboardserial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), motherboardserial,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (motherboardserial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    motherboardserial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.MotherboardSerial)
}

// string Serial = 7;
inline void TargetInfoPacket::clear_serial() {
  serial_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::serial() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.Serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_serial(ArgT0&& arg0, ArgT... args) {
 
 serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.Serial)
}
inline std::string* TargetInfoPacket::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.Serial)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_serial() const {
  return serial_.Get();
}
inline void TargetInfoPacket::_internal_set_serial(const std::string& value) {
  
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_serial() {
  
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_serial() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.Serial)
  return serial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    
  } else {
    
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.Serial)
}

// string Model = 8;
inline void TargetInfoPacket::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::model() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.Model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_model(ArgT0&& arg0, ArgT... args) {
 
 model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.Model)
}
inline std::string* TargetInfoPacket::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.Model)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_model() const {
  return model_.Get();
}
inline void TargetInfoPacket::_internal_set_model(const std::string& value) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_model() {
  
  return model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_model() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.Model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.Model)
}

// string MACAddressLAN = 9;
inline void TargetInfoPacket::clear_macaddresslan() {
  macaddresslan_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::macaddresslan() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.MACAddressLAN)
  return _internal_macaddresslan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_macaddresslan(ArgT0&& arg0, ArgT... args) {
 
 macaddresslan_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.MACAddressLAN)
}
inline std::string* TargetInfoPacket::mutable_macaddresslan() {
  std::string* _s = _internal_mutable_macaddresslan();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.MACAddressLAN)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_macaddresslan() const {
  return macaddresslan_.Get();
}
inline void TargetInfoPacket::_internal_set_macaddresslan(const std::string& value) {
  
  macaddresslan_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_macaddresslan() {
  
  return macaddresslan_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_macaddresslan() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.MACAddressLAN)
  return macaddresslan_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_macaddresslan(std::string* macaddresslan) {
  if (macaddresslan != nullptr) {
    
  } else {
    
  }
  macaddresslan_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), macaddresslan,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (macaddresslan_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    macaddresslan_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.MACAddressLAN)
}

// string MACAddressWIFI = 10;
inline void TargetInfoPacket::clear_macaddresswifi() {
  macaddresswifi_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::macaddresswifi() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.MACAddressWIFI)
  return _internal_macaddresswifi();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_macaddresswifi(ArgT0&& arg0, ArgT... args) {
 
 macaddresswifi_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.MACAddressWIFI)
}
inline std::string* TargetInfoPacket::mutable_macaddresswifi() {
  std::string* _s = _internal_mutable_macaddresswifi();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.MACAddressWIFI)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_macaddresswifi() const {
  return macaddresswifi_.Get();
}
inline void TargetInfoPacket::_internal_set_macaddresswifi(const std::string& value) {
  
  macaddresswifi_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_macaddresswifi() {
  
  return macaddresswifi_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_macaddresswifi() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.MACAddressWIFI)
  return macaddresswifi_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_macaddresswifi(std::string* macaddresswifi) {
  if (macaddresswifi != nullptr) {
    
  } else {
    
  }
  macaddresswifi_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), macaddresswifi,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (macaddresswifi_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    macaddresswifi_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.MACAddressWIFI)
}

// bool UART = 11;
inline void TargetInfoPacket::clear_uart() {
  uart_ = false;
}
inline bool TargetInfoPacket::_internal_uart() const {
  return uart_;
}
inline bool TargetInfoPacket::uart() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.UART)
  return _internal_uart();
}
inline void TargetInfoPacket::_internal_set_uart(bool value) {
  
  uart_ = value;
}
inline void TargetInfoPacket::set_uart(bool value) {
  _internal_set_uart(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.UART)
}

// bool IDUMode = 12;
inline void TargetInfoPacket::clear_idumode() {
  idumode_ = false;
}
inline bool TargetInfoPacket::_internal_idumode() const {
  return idumode_;
}
inline bool TargetInfoPacket::idumode() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.IDUMode)
  return _internal_idumode();
}
inline void TargetInfoPacket::_internal_set_idumode(bool value) {
  
  idumode_ = value;
}
inline void TargetInfoPacket::set_idumode(bool value) {
  _internal_set_idumode(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.IDUMode)
}

// string IDPS = 13;
inline void TargetInfoPacket::clear_idps() {
  idps_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::idps() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.IDPS)
  return _internal_idps();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_idps(ArgT0&& arg0, ArgT... args) {
 
 idps_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.IDPS)
}
inline std::string* TargetInfoPacket::mutable_idps() {
  std::string* _s = _internal_mutable_idps();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.IDPS)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_idps() const {
  return idps_.Get();
}
inline void TargetInfoPacket::_internal_set_idps(const std::string& value) {
  
  idps_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_idps() {
  
  return idps_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_idps() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.IDPS)
  return idps_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_idps(std::string* idps) {
  if (idps != nullptr) {
    
  } else {
    
  }
  idps_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), idps,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idps_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idps_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.IDPS)
}

// string PSID = 14;
inline void TargetInfoPacket::clear_psid() {
  psid_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::psid() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.PSID)
  return _internal_psid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_psid(ArgT0&& arg0, ArgT... args) {
 
 psid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.PSID)
}
inline std::string* TargetInfoPacket::mutable_psid() {
  std::string* _s = _internal_mutable_psid();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.PSID)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_psid() const {
  return psid_.Get();
}
inline void TargetInfoPacket::_internal_set_psid(const std::string& value) {
  
  psid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_psid() {
  
  return psid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_psid() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.PSID)
  return psid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_psid(std::string* psid) {
  if (psid != nullptr) {
    
  } else {
    
  }
  psid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), psid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (psid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    psid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.PSID)
}

// int32 ConsoleType = 15;
inline void TargetInfoPacket::clear_consoletype() {
  consoletype_ = 0;
}
inline int32_t TargetInfoPacket::_internal_consoletype() const {
  return consoletype_;
}
inline int32_t TargetInfoPacket::consoletype() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.ConsoleType)
  return _internal_consoletype();
}
inline void TargetInfoPacket::_internal_set_consoletype(int32_t value) {
  
  consoletype_ = value;
}
inline void TargetInfoPacket::set_consoletype(int32_t value) {
  _internal_set_consoletype(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.ConsoleType)
}

// int32 Attached = 16;
inline void TargetInfoPacket::clear_attached() {
  attached_ = 0;
}
inline int32_t TargetInfoPacket::_internal_attached() const {
  return attached_;
}
inline int32_t TargetInfoPacket::attached() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.Attached)
  return _internal_attached();
}
inline void TargetInfoPacket::_internal_set_attached(int32_t value) {
  
  attached_ = value;
}
inline void TargetInfoPacket::set_attached(int32_t value) {
  _internal_set_attached(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.Attached)
}

// int32 AttachedPid = 17;
inline void TargetInfoPacket::clear_attachedpid() {
  attachedpid_ = 0;
}
inline int32_t TargetInfoPacket::_internal_attachedpid() const {
  return attachedpid_;
}
inline int32_t TargetInfoPacket::attachedpid() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.AttachedPid)
  return _internal_attachedpid();
}
inline void TargetInfoPacket::_internal_set_attachedpid(int32_t value) {
  
  attachedpid_ = value;
}
inline void TargetInfoPacket::set_attachedpid(int32_t value) {
  _internal_set_attachedpid(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.AttachedPid)
}

// int32 ForegroundAccountId = 18;
inline void TargetInfoPacket::clear_foregroundaccountid() {
  foregroundaccountid_ = 0;
}
inline int32_t TargetInfoPacket::_internal_foregroundaccountid() const {
  return foregroundaccountid_;
}
inline int32_t TargetInfoPacket::foregroundaccountid() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.ForegroundAccountId)
  return _internal_foregroundaccountid();
}
inline void TargetInfoPacket::_internal_set_foregroundaccountid(int32_t value) {
  
  foregroundaccountid_ = value;
}
inline void TargetInfoPacket::set_foregroundaccountid(int32_t value) {
  _internal_set_foregroundaccountid(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.ForegroundAccountId)
}

// uint64 FreeSpace = 19;
inline void TargetInfoPacket::clear_freespace() {
  freespace_ = uint64_t{0u};
}
inline uint64_t TargetInfoPacket::_internal_freespace() const {
  return freespace_;
}
inline uint64_t TargetInfoPacket::freespace() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.FreeSpace)
  return _internal_freespace();
}
inline void TargetInfoPacket::_internal_set_freespace(uint64_t value) {
  
  freespace_ = value;
}
inline void TargetInfoPacket::set_freespace(uint64_t value) {
  _internal_set_freespace(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.FreeSpace)
}

// uint64 TotalSpace = 20;
inline void TargetInfoPacket::clear_totalspace() {
  totalspace_ = uint64_t{0u};
}
inline uint64_t TargetInfoPacket::_internal_totalspace() const {
  return totalspace_;
}
inline uint64_t TargetInfoPacket::totalspace() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.TotalSpace)
  return _internal_totalspace();
}
inline void TargetInfoPacket::_internal_set_totalspace(uint64_t value) {
  
  totalspace_ = value;
}
inline void TargetInfoPacket::set_totalspace(uint64_t value) {
  _internal_set_totalspace(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.TotalSpace)
}

// int32 CPUTemp = 21;
inline void TargetInfoPacket::clear_cputemp() {
  cputemp_ = 0;
}
inline int32_t TargetInfoPacket::_internal_cputemp() const {
  return cputemp_;
}
inline int32_t TargetInfoPacket::cputemp() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.CPUTemp)
  return _internal_cputemp();
}
inline void TargetInfoPacket::_internal_set_cputemp(int32_t value) {
  
  cputemp_ = value;
}
inline void TargetInfoPacket::set_cputemp(int32_t value) {
  _internal_set_cputemp(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.CPUTemp)
}

// int32 SOCTemp = 22;
inline void TargetInfoPacket::clear_soctemp() {
  soctemp_ = 0;
}
inline int32_t TargetInfoPacket::_internal_soctemp() const {
  return soctemp_;
}
inline int32_t TargetInfoPacket::soctemp() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.SOCTemp)
  return _internal_soctemp();
}
inline void TargetInfoPacket::_internal_set_soctemp(int32_t value) {
  
  soctemp_ = value;
}
inline void TargetInfoPacket::set_soctemp(int32_t value) {
  _internal_set_soctemp(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.SOCTemp)
}

// int32 ThreadCount = 23;
inline void TargetInfoPacket::clear_threadcount() {
  threadcount_ = 0;
}
inline int32_t TargetInfoPacket::_internal_threadcount() const {
  return threadcount_;
}
inline int32_t TargetInfoPacket::threadcount() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.ThreadCount)
  return _internal_threadcount();
}
inline void TargetInfoPacket::_internal_set_threadcount(int32_t value) {
  
  threadcount_ = value;
}
inline void TargetInfoPacket::set_threadcount(int32_t value) {
  _internal_set_threadcount(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.ThreadCount)
}

// float AverageCPUUsage = 24;
inline void TargetInfoPacket::clear_averagecpuusage() {
  averagecpuusage_ = 0;
}
inline float TargetInfoPacket::_internal_averagecpuusage() const {
  return averagecpuusage_;
}
inline float TargetInfoPacket::averagecpuusage() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.AverageCPUUsage)
  return _internal_averagecpuusage();
}
inline void TargetInfoPacket::_internal_set_averagecpuusage(float value) {
  
  averagecpuusage_ = value;
}
inline void TargetInfoPacket::set_averagecpuusage(float value) {
  _internal_set_averagecpuusage(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.AverageCPUUsage)
}

// int32 BusyCore = 25;
inline void TargetInfoPacket::clear_busycore() {
  busycore_ = 0;
}
inline int32_t TargetInfoPacket::_internal_busycore() const {
  return busycore_;
}
inline int32_t TargetInfoPacket::busycore() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.BusyCore)
  return _internal_busycore();
}
inline void TargetInfoPacket::_internal_set_busycore(int32_t value) {
  
  busycore_ = value;
}
inline void TargetInfoPacket::set_busycore(int32_t value) {
  _internal_set_busycore(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.BusyCore)
}

// .MemoryInfo Ram = 26;
inline bool TargetInfoPacket::_internal_has_ram() const {
  return this != internal_default_instance() && ram_ != nullptr;
}
inline bool TargetInfoPacket::has_ram() const {
  return _internal_has_ram();
}
inline void TargetInfoPacket::clear_ram() {
  if (GetArenaForAllocation() == nullptr && ram_ != nullptr) {
    delete ram_;
  }
  ram_ = nullptr;
}
inline const ::MemoryInfo& TargetInfoPacket::_internal_ram() const {
  const ::MemoryInfo* p = ram_;
  return p != nullptr ? *p : reinterpret_cast<const ::MemoryInfo&>(
      ::_MemoryInfo_default_instance_);
}
inline const ::MemoryInfo& TargetInfoPacket::ram() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.Ram)
  return _internal_ram();
}
inline void TargetInfoPacket::unsafe_arena_set_allocated_ram(
    ::MemoryInfo* ram) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ram_);
  }
  ram_ = ram;
  if (ram) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TargetInfoPacket.Ram)
}
inline ::MemoryInfo* TargetInfoPacket::release_ram() {
  
  ::MemoryInfo* temp = ram_;
  ram_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MemoryInfo* TargetInfoPacket::unsafe_arena_release_ram() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.Ram)
  
  ::MemoryInfo* temp = ram_;
  ram_ = nullptr;
  return temp;
}
inline ::MemoryInfo* TargetInfoPacket::_internal_mutable_ram() {
  
  if (ram_ == nullptr) {
    auto* p = CreateMaybeMessage<::MemoryInfo>(GetArenaForAllocation());
    ram_ = p;
  }
  return ram_;
}
inline ::MemoryInfo* TargetInfoPacket::mutable_ram() {
  ::MemoryInfo* _msg = _internal_mutable_ram();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.Ram)
  return _msg;
}
inline void TargetInfoPacket::set_allocated_ram(::MemoryInfo* ram) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ram_;
  }
  if (ram) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MemoryInfo>::GetOwningArena(ram);
    if (message_arena != submessage_arena) {
      ram = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ram, submessage_arena);
    }
    
  } else {
    
  }
  ram_ = ram;
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.Ram)
}

// .MemoryInfo VRam = 27;
inline bool TargetInfoPacket::_internal_has_vram() const {
  return this != internal_default_instance() && vram_ != nullptr;
}
inline bool TargetInfoPacket::has_vram() const {
  return _internal_has_vram();
}
inline void TargetInfoPacket::clear_vram() {
  if (GetArenaForAllocation() == nullptr && vram_ != nullptr) {
    delete vram_;
  }
  vram_ = nullptr;
}
inline const ::MemoryInfo& TargetInfoPacket::_internal_vram() const {
  const ::MemoryInfo* p = vram_;
  return p != nullptr ? *p : reinterpret_cast<const ::MemoryInfo&>(
      ::_MemoryInfo_default_instance_);
}
inline const ::MemoryInfo& TargetInfoPacket::vram() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.VRam)
  return _internal_vram();
}
inline void TargetInfoPacket::unsafe_arena_set_allocated_vram(
    ::MemoryInfo* vram) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vram_);
  }
  vram_ = vram;
  if (vram) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TargetInfoPacket.VRam)
}
inline ::MemoryInfo* TargetInfoPacket::release_vram() {
  
  ::MemoryInfo* temp = vram_;
  vram_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MemoryInfo* TargetInfoPacket::unsafe_arena_release_vram() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.VRam)
  
  ::MemoryInfo* temp = vram_;
  vram_ = nullptr;
  return temp;
}
inline ::MemoryInfo* TargetInfoPacket::_internal_mutable_vram() {
  
  if (vram_ == nullptr) {
    auto* p = CreateMaybeMessage<::MemoryInfo>(GetArenaForAllocation());
    vram_ = p;
  }
  return vram_;
}
inline ::MemoryInfo* TargetInfoPacket::mutable_vram() {
  ::MemoryInfo* _msg = _internal_mutable_vram();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.VRam)
  return _msg;
}
inline void TargetInfoPacket::set_allocated_vram(::MemoryInfo* vram) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete vram_;
  }
  if (vram) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MemoryInfo>::GetOwningArena(vram);
    if (message_arena != submessage_arena) {
      vram = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vram, submessage_arena);
    }
    
  } else {
    
  }
  vram_ = vram;
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.VRam)
}

// -------------------------------------------------------------------

// TargetNotifyPacket

// string IconURI = 1;
inline void TargetNotifyPacket::clear_iconuri() {
  iconuri_.ClearToEmpty();
}
inline const std::string& TargetNotifyPacket::iconuri() const {
  // @@protoc_insertion_point(field_get:TargetNotifyPacket.IconURI)
  return _internal_iconuri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetNotifyPacket::set_iconuri(ArgT0&& arg0, ArgT... args) {
 
 iconuri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetNotifyPacket.IconURI)
}
inline std::string* TargetNotifyPacket::mutable_iconuri() {
  std::string* _s = _internal_mutable_iconuri();
  // @@protoc_insertion_point(field_mutable:TargetNotifyPacket.IconURI)
  return _s;
}
inline const std::string& TargetNotifyPacket::_internal_iconuri() const {
  return iconuri_.Get();
}
inline void TargetNotifyPacket::_internal_set_iconuri(const std::string& value) {
  
  iconuri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetNotifyPacket::_internal_mutable_iconuri() {
  
  return iconuri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetNotifyPacket::release_iconuri() {
  // @@protoc_insertion_point(field_release:TargetNotifyPacket.IconURI)
  return iconuri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetNotifyPacket::set_allocated_iconuri(std::string* iconuri) {
  if (iconuri != nullptr) {
    
  } else {
    
  }
  iconuri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iconuri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iconuri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    iconuri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetNotifyPacket.IconURI)
}

// string Message = 2;
inline void TargetNotifyPacket::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& TargetNotifyPacket::message() const {
  // @@protoc_insertion_point(field_get:TargetNotifyPacket.Message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetNotifyPacket::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetNotifyPacket.Message)
}
inline std::string* TargetNotifyPacket::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:TargetNotifyPacket.Message)
  return _s;
}
inline const std::string& TargetNotifyPacket::_internal_message() const {
  return message_.Get();
}
inline void TargetNotifyPacket::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetNotifyPacket::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetNotifyPacket::release_message() {
  // @@protoc_insertion_point(field_release:TargetNotifyPacket.Message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetNotifyPacket::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetNotifyPacket.Message)
}

// -------------------------------------------------------------------

// TargetSettingsPacket

// bool AutoLoadSettings = 1;
inline void TargetSettingsPacket::clear_autoloadsettings() {
  autoloadsettings_ = false;
}
inline bool TargetSettingsPacket::_internal_autoloadsettings() const {
  return autoloadsettings_;
}
inline bool TargetSettingsPacket::autoloadsettings() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.AutoLoadSettings)
  return _internal_autoloadsettings();
}
inline void TargetSettingsPacket::_internal_set_autoloadsettings(bool value) {
  
  autoloadsettings_ = value;
}
inline void TargetSettingsPacket::set_autoloadsettings(bool value) {
  _internal_set_autoloadsettings(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.AutoLoadSettings)
}

// bool ShowDebugTitleIdLabel = 2;
inline void TargetSettingsPacket::clear_showdebugtitleidlabel() {
  showdebugtitleidlabel_ = false;
}
inline bool TargetSettingsPacket::_internal_showdebugtitleidlabel() const {
  return showdebugtitleidlabel_;
}
inline bool TargetSettingsPacket::showdebugtitleidlabel() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.ShowDebugTitleIdLabel)
  return _internal_showdebugtitleidlabel();
}
inline void TargetSettingsPacket::_internal_set_showdebugtitleidlabel(bool value) {
  
  showdebugtitleidlabel_ = value;
}
inline void TargetSettingsPacket::set_showdebugtitleidlabel(bool value) {
  _internal_set_showdebugtitleidlabel(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.ShowDebugTitleIdLabel)
}

// bool ShowDevkitPanel = 3;
inline void TargetSettingsPacket::clear_showdevkitpanel() {
  showdevkitpanel_ = false;
}
inline bool TargetSettingsPacket::_internal_showdevkitpanel() const {
  return showdevkitpanel_;
}
inline bool TargetSettingsPacket::showdevkitpanel() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.ShowDevkitPanel)
  return _internal_showdevkitpanel();
}
inline void TargetSettingsPacket::_internal_set_showdevkitpanel(bool value) {
  
  showdevkitpanel_ = value;
}
inline void TargetSettingsPacket::set_showdevkitpanel(bool value) {
  _internal_set_showdevkitpanel(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.ShowDevkitPanel)
}

// bool ShowDebugSettings = 4;
inline void TargetSettingsPacket::clear_showdebugsettings() {
  showdebugsettings_ = false;
}
inline bool TargetSettingsPacket::_internal_showdebugsettings() const {
  return showdebugsettings_;
}
inline bool TargetSettingsPacket::showdebugsettings() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.ShowDebugSettings)
  return _internal_showdebugsettings();
}
inline void TargetSettingsPacket::_internal_set_showdebugsettings(bool value) {
  
  showdebugsettings_ = value;
}
inline void TargetSettingsPacket::set_showdebugsettings(bool value) {
  _internal_set_showdebugsettings(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.ShowDebugSettings)
}

// bool ShowAppHome = 5;
inline void TargetSettingsPacket::clear_showapphome() {
  showapphome_ = false;
}
inline bool TargetSettingsPacket::_internal_showapphome() const {
  return showapphome_;
}
inline bool TargetSettingsPacket::showapphome() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.ShowAppHome)
  return _internal_showapphome();
}
inline void TargetSettingsPacket::_internal_set_showapphome(bool value) {
  
  showapphome_ = value;
}
inline void TargetSettingsPacket::set_showapphome(bool value) {
  _internal_set_showapphome(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.ShowAppHome)
}

// bool ShowBuildOverlay = 6;
inline void TargetSettingsPacket::clear_showbuildoverlay() {
  showbuildoverlay_ = false;
}
inline bool TargetSettingsPacket::_internal_showbuildoverlay() const {
  return showbuildoverlay_;
}
inline bool TargetSettingsPacket::showbuildoverlay() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.ShowBuildOverlay)
  return _internal_showbuildoverlay();
}
inline void TargetSettingsPacket::_internal_set_showbuildoverlay(bool value) {
  
  showbuildoverlay_ = value;
}
inline void TargetSettingsPacket::set_showbuildoverlay(bool value) {
  _internal_set_showbuildoverlay(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.ShowBuildOverlay)
}

// string GameOverlayLocation = 7;
inline void TargetSettingsPacket::clear_gameoverlaylocation() {
  gameoverlaylocation_.ClearToEmpty();
}
inline const std::string& TargetSettingsPacket::gameoverlaylocation() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.GameOverlayLocation)
  return _internal_gameoverlaylocation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetSettingsPacket::set_gameoverlaylocation(ArgT0&& arg0, ArgT... args) {
 
 gameoverlaylocation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.GameOverlayLocation)
}
inline std::string* TargetSettingsPacket::mutable_gameoverlaylocation() {
  std::string* _s = _internal_mutable_gameoverlaylocation();
  // @@protoc_insertion_point(field_mutable:TargetSettingsPacket.GameOverlayLocation)
  return _s;
}
inline const std::string& TargetSettingsPacket::_internal_gameoverlaylocation() const {
  return gameoverlaylocation_.Get();
}
inline void TargetSettingsPacket::_internal_set_gameoverlaylocation(const std::string& value) {
  
  gameoverlaylocation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetSettingsPacket::_internal_mutable_gameoverlaylocation() {
  
  return gameoverlaylocation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetSettingsPacket::release_gameoverlaylocation() {
  // @@protoc_insertion_point(field_release:TargetSettingsPacket.GameOverlayLocation)
  return gameoverlaylocation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetSettingsPacket::set_allocated_gameoverlaylocation(std::string* gameoverlaylocation) {
  if (gameoverlaylocation != nullptr) {
    
  } else {
    
  }
  gameoverlaylocation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gameoverlaylocation,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gameoverlaylocation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gameoverlaylocation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetSettingsPacket.GameOverlayLocation)
}

// bool ShowCPUUsage = 8;
inline void TargetSettingsPacket::clear_showcpuusage() {
  showcpuusage_ = false;
}
inline bool TargetSettingsPacket::_internal_showcpuusage() const {
  return showcpuusage_;
}
inline bool TargetSettingsPacket::showcpuusage() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.ShowCPUUsage)
  return _internal_showcpuusage();
}
inline void TargetSettingsPacket::_internal_set_showcpuusage(bool value) {
  
  showcpuusage_ = value;
}
inline void TargetSettingsPacket::set_showcpuusage(bool value) {
  _internal_set_showcpuusage(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.ShowCPUUsage)
}

// bool ShowThreadCount = 9;
inline void TargetSettingsPacket::clear_showthreadcount() {
  showthreadcount_ = false;
}
inline bool TargetSettingsPacket::_internal_showthreadcount() const {
  return showthreadcount_;
}
inline bool TargetSettingsPacket::showthreadcount() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.ShowThreadCount)
  return _internal_showthreadcount();
}
inline void TargetSettingsPacket::_internal_set_showthreadcount(bool value) {
  
  showthreadcount_ = value;
}
inline void TargetSettingsPacket::set_showthreadcount(bool value) {
  _internal_set_showthreadcount(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.ShowThreadCount)
}

// bool Showram = 10;
inline void TargetSettingsPacket::clear_showram() {
  showram_ = false;
}
inline bool TargetSettingsPacket::_internal_showram() const {
  return showram_;
}
inline bool TargetSettingsPacket::showram() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.Showram)
  return _internal_showram();
}
inline void TargetSettingsPacket::_internal_set_showram(bool value) {
  
  showram_ = value;
}
inline void TargetSettingsPacket::set_showram(bool value) {
  _internal_set_showram(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.Showram)
}

// bool Showvram = 11;
inline void TargetSettingsPacket::clear_showvram() {
  showvram_ = false;
}
inline bool TargetSettingsPacket::_internal_showvram() const {
  return showvram_;
}
inline bool TargetSettingsPacket::showvram() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.Showvram)
  return _internal_showvram();
}
inline void TargetSettingsPacket::_internal_set_showvram(bool value) {
  
  showvram_ = value;
}
inline void TargetSettingsPacket::set_showvram(bool value) {
  _internal_set_showvram(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.Showvram)
}

// bool ShowCPUTemp = 12;
inline void TargetSettingsPacket::clear_showcputemp() {
  showcputemp_ = false;
}
inline bool TargetSettingsPacket::_internal_showcputemp() const {
  return showcputemp_;
}
inline bool TargetSettingsPacket::showcputemp() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.ShowCPUTemp)
  return _internal_showcputemp();
}
inline void TargetSettingsPacket::_internal_set_showcputemp(bool value) {
  
  showcputemp_ = value;
}
inline void TargetSettingsPacket::set_showcputemp(bool value) {
  _internal_set_showcputemp(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.ShowCPUTemp)
}

// bool ShowSOCTemp = 13;
inline void TargetSettingsPacket::clear_showsoctemp() {
  showsoctemp_ = false;
}
inline bool TargetSettingsPacket::_internal_showsoctemp() const {
  return showsoctemp_;
}
inline bool TargetSettingsPacket::showsoctemp() const {
  // @@protoc_insertion_point(field_get:TargetSettingsPacket.ShowSOCTemp)
  return _internal_showsoctemp();
}
inline void TargetSettingsPacket::_internal_set_showsoctemp(bool value) {
  
  showsoctemp_ = value;
}
inline void TargetSettingsPacket::set_showsoctemp(bool value) {
  _internal_set_showsoctemp(value);
  // @@protoc_insertion_point(field_set:TargetSettingsPacket.ShowSOCTemp)
}

// -------------------------------------------------------------------

// ProcPacket

// int32 AppId = 1;
inline void ProcPacket::clear_appid() {
  appid_ = 0;
}
inline int32_t ProcPacket::_internal_appid() const {
  return appid_;
}
inline int32_t ProcPacket::appid() const {
  // @@protoc_insertion_point(field_get:ProcPacket.AppId)
  return _internal_appid();
}
inline void ProcPacket::_internal_set_appid(int32_t value) {
  
  appid_ = value;
}
inline void ProcPacket::set_appid(int32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:ProcPacket.AppId)
}

// int32 ProcessId = 2;
inline void ProcPacket::clear_processid() {
  processid_ = 0;
}
inline int32_t ProcPacket::_internal_processid() const {
  return processid_;
}
inline int32_t ProcPacket::processid() const {
  // @@protoc_insertion_point(field_get:ProcPacket.ProcessId)
  return _internal_processid();
}
inline void ProcPacket::_internal_set_processid(int32_t value) {
  
  processid_ = value;
}
inline void ProcPacket::set_processid(int32_t value) {
  _internal_set_processid(value);
  // @@protoc_insertion_point(field_set:ProcPacket.ProcessId)
}

// string Name = 3;
inline void ProcPacket::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ProcPacket::name() const {
  // @@protoc_insertion_point(field_get:ProcPacket.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcPacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcPacket.Name)
}
inline std::string* ProcPacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ProcPacket.Name)
  return _s;
}
inline const std::string& ProcPacket::_internal_name() const {
  return name_.Get();
}
inline void ProcPacket::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProcPacket::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProcPacket::release_name() {
  // @@protoc_insertion_point(field_release:ProcPacket.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProcPacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcPacket.Name)
}

// string TitleId = 4;
inline void ProcPacket::clear_titleid() {
  titleid_.ClearToEmpty();
}
inline const std::string& ProcPacket::titleid() const {
  // @@protoc_insertion_point(field_get:ProcPacket.TitleId)
  return _internal_titleid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcPacket::set_titleid(ArgT0&& arg0, ArgT... args) {
 
 titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcPacket.TitleId)
}
inline std::string* ProcPacket::mutable_titleid() {
  std::string* _s = _internal_mutable_titleid();
  // @@protoc_insertion_point(field_mutable:ProcPacket.TitleId)
  return _s;
}
inline const std::string& ProcPacket::_internal_titleid() const {
  return titleid_.Get();
}
inline void ProcPacket::_internal_set_titleid(const std::string& value) {
  
  titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProcPacket::_internal_mutable_titleid() {
  
  return titleid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProcPacket::release_titleid() {
  // @@protoc_insertion_point(field_release:ProcPacket.TitleId)
  return titleid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProcPacket::set_allocated_titleid(std::string* titleid) {
  if (titleid != nullptr) {
    
  } else {
    
  }
  titleid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), titleid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (titleid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    titleid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcPacket.TitleId)
}

// -------------------------------------------------------------------

// ProcListPacket

// repeated .ProcPacket Processes = 1;
inline int ProcListPacket::_internal_processes_size() const {
  return processes_.size();
}
inline int ProcListPacket::processes_size() const {
  return _internal_processes_size();
}
inline void ProcListPacket::clear_processes() {
  processes_.Clear();
}
inline ::ProcPacket* ProcListPacket::mutable_processes(int index) {
  // @@protoc_insertion_point(field_mutable:ProcListPacket.Processes)
  return processes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProcPacket >*
ProcListPacket::mutable_processes() {
  // @@protoc_insertion_point(field_mutable_list:ProcListPacket.Processes)
  return &processes_;
}
inline const ::ProcPacket& ProcListPacket::_internal_processes(int index) const {
  return processes_.Get(index);
}
inline const ::ProcPacket& ProcListPacket::processes(int index) const {
  // @@protoc_insertion_point(field_get:ProcListPacket.Processes)
  return _internal_processes(index);
}
inline ::ProcPacket* ProcListPacket::_internal_add_processes() {
  return processes_.Add();
}
inline ::ProcPacket* ProcListPacket::add_processes() {
  ::ProcPacket* _add = _internal_add_processes();
  // @@protoc_insertion_point(field_add:ProcListPacket.Processes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ProcPacket >&
ProcListPacket::processes() const {
  // @@protoc_insertion_point(field_list:ProcListPacket.Processes)
  return processes_;
}

// -------------------------------------------------------------------

// LibraryInfoPacket

// uint32 Handle = 1;
inline void LibraryInfoPacket::clear_handle() {
  handle_ = 0u;
}
inline uint32_t LibraryInfoPacket::_internal_handle() const {
  return handle_;
}
inline uint32_t LibraryInfoPacket::handle() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.Handle)
  return _internal_handle();
}
inline void LibraryInfoPacket::_internal_set_handle(uint32_t value) {
  
  handle_ = value;
}
inline void LibraryInfoPacket::set_handle(uint32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.Handle)
}

// string Path = 2;
inline void LibraryInfoPacket::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& LibraryInfoPacket::path() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryInfoPacket::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.Path)
}
inline std::string* LibraryInfoPacket::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:LibraryInfoPacket.Path)
  return _s;
}
inline const std::string& LibraryInfoPacket::_internal_path() const {
  return path_.Get();
}
inline void LibraryInfoPacket::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LibraryInfoPacket::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LibraryInfoPacket::release_path() {
  // @@protoc_insertion_point(field_release:LibraryInfoPacket.Path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LibraryInfoPacket::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LibraryInfoPacket.Path)
}

// uint64 MapBase = 3;
inline void LibraryInfoPacket::clear_mapbase() {
  mapbase_ = uint64_t{0u};
}
inline uint64_t LibraryInfoPacket::_internal_mapbase() const {
  return mapbase_;
}
inline uint64_t LibraryInfoPacket::mapbase() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.MapBase)
  return _internal_mapbase();
}
inline void LibraryInfoPacket::_internal_set_mapbase(uint64_t value) {
  
  mapbase_ = value;
}
inline void LibraryInfoPacket::set_mapbase(uint64_t value) {
  _internal_set_mapbase(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.MapBase)
}

// uint64 MapSize = 4;
inline void LibraryInfoPacket::clear_mapsize() {
  mapsize_ = uint64_t{0u};
}
inline uint64_t LibraryInfoPacket::_internal_mapsize() const {
  return mapsize_;
}
inline uint64_t LibraryInfoPacket::mapsize() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.MapSize)
  return _internal_mapsize();
}
inline void LibraryInfoPacket::_internal_set_mapsize(uint64_t value) {
  
  mapsize_ = value;
}
inline void LibraryInfoPacket::set_mapsize(uint64_t value) {
  _internal_set_mapsize(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.MapSize)
}

// uint64 TextSize = 5;
inline void LibraryInfoPacket::clear_textsize() {
  textsize_ = uint64_t{0u};
}
inline uint64_t LibraryInfoPacket::_internal_textsize() const {
  return textsize_;
}
inline uint64_t LibraryInfoPacket::textsize() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.TextSize)
  return _internal_textsize();
}
inline void LibraryInfoPacket::_internal_set_textsize(uint64_t value) {
  
  textsize_ = value;
}
inline void LibraryInfoPacket::set_textsize(uint64_t value) {
  _internal_set_textsize(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.TextSize)
}

// uint64 DataBase = 6;
inline void LibraryInfoPacket::clear_database() {
  database_ = uint64_t{0u};
}
inline uint64_t LibraryInfoPacket::_internal_database() const {
  return database_;
}
inline uint64_t LibraryInfoPacket::database() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.DataBase)
  return _internal_database();
}
inline void LibraryInfoPacket::_internal_set_database(uint64_t value) {
  
  database_ = value;
}
inline void LibraryInfoPacket::set_database(uint64_t value) {
  _internal_set_database(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.DataBase)
}

// uint64 DataSize = 7;
inline void LibraryInfoPacket::clear_datasize() {
  datasize_ = uint64_t{0u};
}
inline uint64_t LibraryInfoPacket::_internal_datasize() const {
  return datasize_;
}
inline uint64_t LibraryInfoPacket::datasize() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.DataSize)
  return _internal_datasize();
}
inline void LibraryInfoPacket::_internal_set_datasize(uint64_t value) {
  
  datasize_ = value;
}
inline void LibraryInfoPacket::set_datasize(uint64_t value) {
  _internal_set_datasize(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.DataSize)
}

// -------------------------------------------------------------------

// LibraryListPacket

// repeated .LibraryInfoPacket Libraries = 1;
inline int LibraryListPacket::_internal_libraries_size() const {
  return libraries_.size();
}
inline int LibraryListPacket::libraries_size() const {
  return _internal_libraries_size();
}
inline void LibraryListPacket::clear_libraries() {
  libraries_.Clear();
}
inline ::LibraryInfoPacket* LibraryListPacket::mutable_libraries(int index) {
  // @@protoc_insertion_point(field_mutable:LibraryListPacket.Libraries)
  return libraries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LibraryInfoPacket >*
LibraryListPacket::mutable_libraries() {
  // @@protoc_insertion_point(field_mutable_list:LibraryListPacket.Libraries)
  return &libraries_;
}
inline const ::LibraryInfoPacket& LibraryListPacket::_internal_libraries(int index) const {
  return libraries_.Get(index);
}
inline const ::LibraryInfoPacket& LibraryListPacket::libraries(int index) const {
  // @@protoc_insertion_point(field_get:LibraryListPacket.Libraries)
  return _internal_libraries(index);
}
inline ::LibraryInfoPacket* LibraryListPacket::_internal_add_libraries() {
  return libraries_.Add();
}
inline ::LibraryInfoPacket* LibraryListPacket::add_libraries() {
  ::LibraryInfoPacket* _add = _internal_add_libraries();
  // @@protoc_insertion_point(field_add:LibraryListPacket.Libraries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::LibraryInfoPacket >&
LibraryListPacket::libraries() const {
  // @@protoc_insertion_point(field_list:LibraryListPacket.Libraries)
  return libraries_;
}

// -------------------------------------------------------------------

// PagePacket

// string Name = 1;
inline void PagePacket::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PagePacket::name() const {
  // @@protoc_insertion_point(field_get:PagePacket.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PagePacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PagePacket.Name)
}
inline std::string* PagePacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PagePacket.Name)
  return _s;
}
inline const std::string& PagePacket::_internal_name() const {
  return name_.Get();
}
inline void PagePacket::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PagePacket::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PagePacket::release_name() {
  // @@protoc_insertion_point(field_release:PagePacket.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PagePacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PagePacket.Name)
}

// uint64 Start = 2;
inline void PagePacket::clear_start() {
  start_ = uint64_t{0u};
}
inline uint64_t PagePacket::_internal_start() const {
  return start_;
}
inline uint64_t PagePacket::start() const {
  // @@protoc_insertion_point(field_get:PagePacket.Start)
  return _internal_start();
}
inline void PagePacket::_internal_set_start(uint64_t value) {
  
  start_ = value;
}
inline void PagePacket::set_start(uint64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:PagePacket.Start)
}

// uint64 End = 3;
inline void PagePacket::clear_end() {
  end_ = uint64_t{0u};
}
inline uint64_t PagePacket::_internal_end() const {
  return end_;
}
inline uint64_t PagePacket::end() const {
  // @@protoc_insertion_point(field_get:PagePacket.End)
  return _internal_end();
}
inline void PagePacket::_internal_set_end(uint64_t value) {
  
  end_ = value;
}
inline void PagePacket::set_end(uint64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:PagePacket.End)
}

// uint64 Offset = 4;
inline void PagePacket::clear_offset() {
  offset_ = uint64_t{0u};
}
inline uint64_t PagePacket::_internal_offset() const {
  return offset_;
}
inline uint64_t PagePacket::offset() const {
  // @@protoc_insertion_point(field_get:PagePacket.Offset)
  return _internal_offset();
}
inline void PagePacket::_internal_set_offset(uint64_t value) {
  
  offset_ = value;
}
inline void PagePacket::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:PagePacket.Offset)
}

// uint64 Size = 5;
inline void PagePacket::clear_size() {
  size_ = uint64_t{0u};
}
inline uint64_t PagePacket::_internal_size() const {
  return size_;
}
inline uint64_t PagePacket::size() const {
  // @@protoc_insertion_point(field_get:PagePacket.Size)
  return _internal_size();
}
inline void PagePacket::_internal_set_size(uint64_t value) {
  
  size_ = value;
}
inline void PagePacket::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:PagePacket.Size)
}

// uint32 Prot = 6;
inline void PagePacket::clear_prot() {
  prot_ = 0u;
}
inline uint32_t PagePacket::_internal_prot() const {
  return prot_;
}
inline uint32_t PagePacket::prot() const {
  // @@protoc_insertion_point(field_get:PagePacket.Prot)
  return _internal_prot();
}
inline void PagePacket::_internal_set_prot(uint32_t value) {
  
  prot_ = value;
}
inline void PagePacket::set_prot(uint32_t value) {
  _internal_set_prot(value);
  // @@protoc_insertion_point(field_set:PagePacket.Prot)
}

// -------------------------------------------------------------------

// PagesListPacket

// repeated .PagePacket Pages = 1;
inline int PagesListPacket::_internal_pages_size() const {
  return pages_.size();
}
inline int PagesListPacket::pages_size() const {
  return _internal_pages_size();
}
inline void PagesListPacket::clear_pages() {
  pages_.Clear();
}
inline ::PagePacket* PagesListPacket::mutable_pages(int index) {
  // @@protoc_insertion_point(field_mutable:PagesListPacket.Pages)
  return pages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PagePacket >*
PagesListPacket::mutable_pages() {
  // @@protoc_insertion_point(field_mutable_list:PagesListPacket.Pages)
  return &pages_;
}
inline const ::PagePacket& PagesListPacket::_internal_pages(int index) const {
  return pages_.Get(index);
}
inline const ::PagePacket& PagesListPacket::pages(int index) const {
  // @@protoc_insertion_point(field_get:PagesListPacket.Pages)
  return _internal_pages(index);
}
inline ::PagePacket* PagesListPacket::_internal_add_pages() {
  return pages_.Add();
}
inline ::PagePacket* PagesListPacket::add_pages() {
  ::PagePacket* _add = _internal_add_pages();
  // @@protoc_insertion_point(field_add:PagesListPacket.Pages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PagePacket >&
PagesListPacket::pages() const {
  // @@protoc_insertion_point(field_list:PagesListPacket.Pages)
  return pages_;
}

// -------------------------------------------------------------------

// NamedObjectPacket

// string Name = 1;
inline void NamedObjectPacket::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NamedObjectPacket::name() const {
  // @@protoc_insertion_point(field_get:NamedObjectPacket.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedObjectPacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NamedObjectPacket.Name)
}
inline std::string* NamedObjectPacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NamedObjectPacket.Name)
  return _s;
}
inline const std::string& NamedObjectPacket::_internal_name() const {
  return name_.Get();
}
inline void NamedObjectPacket::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NamedObjectPacket::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NamedObjectPacket::release_name() {
  // @@protoc_insertion_point(field_release:NamedObjectPacket.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NamedObjectPacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NamedObjectPacket.Name)
}

// -------------------------------------------------------------------

// NamedObjectListPacket

// repeated .NamedObjectPacket Objects = 1;
inline int NamedObjectListPacket::_internal_objects_size() const {
  return objects_.size();
}
inline int NamedObjectListPacket::objects_size() const {
  return _internal_objects_size();
}
inline void NamedObjectListPacket::clear_objects() {
  objects_.Clear();
}
inline ::NamedObjectPacket* NamedObjectListPacket::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:NamedObjectListPacket.Objects)
  return objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NamedObjectPacket >*
NamedObjectListPacket::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:NamedObjectListPacket.Objects)
  return &objects_;
}
inline const ::NamedObjectPacket& NamedObjectListPacket::_internal_objects(int index) const {
  return objects_.Get(index);
}
inline const ::NamedObjectPacket& NamedObjectListPacket::objects(int index) const {
  // @@protoc_insertion_point(field_get:NamedObjectListPacket.Objects)
  return _internal_objects(index);
}
inline ::NamedObjectPacket* NamedObjectListPacket::_internal_add_objects() {
  return objects_.Add();
}
inline ::NamedObjectPacket* NamedObjectListPacket::add_objects() {
  ::NamedObjectPacket* _add = _internal_add_objects();
  // @@protoc_insertion_point(field_add:NamedObjectListPacket.Objects)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NamedObjectPacket >&
NamedObjectListPacket::objects() const {
  // @@protoc_insertion_point(field_list:NamedObjectListPacket.Objects)
  return objects_;
}

// -------------------------------------------------------------------

// FilePacket

// string FilePath = 1;
inline void FilePacket::clear_filepath() {
  filepath_.ClearToEmpty();
}
inline const std::string& FilePacket::filepath() const {
  // @@protoc_insertion_point(field_get:FilePacket.FilePath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FilePacket::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 filepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FilePacket.FilePath)
}
inline std::string* FilePacket::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:FilePacket.FilePath)
  return _s;
}
inline const std::string& FilePacket::_internal_filepath() const {
  return filepath_.Get();
}
inline void FilePacket::_internal_set_filepath(const std::string& value) {
  
  filepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FilePacket::_internal_mutable_filepath() {
  
  return filepath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FilePacket::release_filepath() {
  // @@protoc_insertion_point(field_release:FilePacket.FilePath)
  return filepath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FilePacket::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  filepath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filepath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FilePacket.FilePath)
}

// -------------------------------------------------------------------

// ThreadInfoPacket

// uint32 TID = 1;
inline void ThreadInfoPacket::clear_tid() {
  tid_ = 0u;
}
inline uint32_t ThreadInfoPacket::_internal_tid() const {
  return tid_;
}
inline uint32_t ThreadInfoPacket::tid() const {
  // @@protoc_insertion_point(field_get:ThreadInfoPacket.TID)
  return _internal_tid();
}
inline void ThreadInfoPacket::_internal_set_tid(uint32_t value) {
  
  tid_ = value;
}
inline void ThreadInfoPacket::set_tid(uint32_t value) {
  _internal_set_tid(value);
  // @@protoc_insertion_point(field_set:ThreadInfoPacket.TID)
}

// string Name = 2;
inline void ThreadInfoPacket::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ThreadInfoPacket::name() const {
  // @@protoc_insertion_point(field_get:ThreadInfoPacket.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ThreadInfoPacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ThreadInfoPacket.Name)
}
inline std::string* ThreadInfoPacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ThreadInfoPacket.Name)
  return _s;
}
inline const std::string& ThreadInfoPacket::_internal_name() const {
  return name_.Get();
}
inline void ThreadInfoPacket::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ThreadInfoPacket::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ThreadInfoPacket::release_name() {
  // @@protoc_insertion_point(field_release:ThreadInfoPacket.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ThreadInfoPacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ThreadInfoPacket.Name)
}

// -------------------------------------------------------------------

// ThreadListPacket

// repeated .ThreadInfoPacket Threads = 1;
inline int ThreadListPacket::_internal_threads_size() const {
  return threads_.size();
}
inline int ThreadListPacket::threads_size() const {
  return _internal_threads_size();
}
inline void ThreadListPacket::clear_threads() {
  threads_.Clear();
}
inline ::ThreadInfoPacket* ThreadListPacket::mutable_threads(int index) {
  // @@protoc_insertion_point(field_mutable:ThreadListPacket.Threads)
  return threads_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ThreadInfoPacket >*
ThreadListPacket::mutable_threads() {
  // @@protoc_insertion_point(field_mutable_list:ThreadListPacket.Threads)
  return &threads_;
}
inline const ::ThreadInfoPacket& ThreadListPacket::_internal_threads(int index) const {
  return threads_.Get(index);
}
inline const ::ThreadInfoPacket& ThreadListPacket::threads(int index) const {
  // @@protoc_insertion_point(field_get:ThreadListPacket.Threads)
  return _internal_threads(index);
}
inline ::ThreadInfoPacket* ThreadListPacket::_internal_add_threads() {
  return threads_.Add();
}
inline ::ThreadInfoPacket* ThreadListPacket::add_threads() {
  ::ThreadInfoPacket* _add = _internal_add_threads();
  // @@protoc_insertion_point(field_add:ThreadListPacket.Threads)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ThreadInfoPacket >&
ThreadListPacket::threads() const {
  // @@protoc_insertion_point(field_list:ThreadListPacket.Threads)
  return threads_;
}

// -------------------------------------------------------------------

// WatchpointPacket

// uint32 Index = 1;
inline void WatchpointPacket::clear_index() {
  index_ = 0u;
}
inline uint32_t WatchpointPacket::_internal_index() const {
  return index_;
}
inline uint32_t WatchpointPacket::index() const {
  // @@protoc_insertion_point(field_get:WatchpointPacket.Index)
  return _internal_index();
}
inline void WatchpointPacket::_internal_set_index(uint32_t value) {
  
  index_ = value;
}
inline void WatchpointPacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:WatchpointPacket.Index)
}

// bool Enabled = 2;
inline void WatchpointPacket::clear_enabled() {
  enabled_ = false;
}
inline bool WatchpointPacket::_internal_enabled() const {
  return enabled_;
}
inline bool WatchpointPacket::enabled() const {
  // @@protoc_insertion_point(field_get:WatchpointPacket.Enabled)
  return _internal_enabled();
}
inline void WatchpointPacket::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void WatchpointPacket::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:WatchpointPacket.Enabled)
}

// uint64 Address = 3;
inline void WatchpointPacket::clear_address() {
  address_ = uint64_t{0u};
}
inline uint64_t WatchpointPacket::_internal_address() const {
  return address_;
}
inline uint64_t WatchpointPacket::address() const {
  // @@protoc_insertion_point(field_get:WatchpointPacket.Address)
  return _internal_address();
}
inline void WatchpointPacket::_internal_set_address(uint64_t value) {
  
  address_ = value;
}
inline void WatchpointPacket::set_address(uint64_t value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:WatchpointPacket.Address)
}

// uint32 Type = 4;
inline void WatchpointPacket::clear_type() {
  type_ = 0u;
}
inline uint32_t WatchpointPacket::_internal_type() const {
  return type_;
}
inline uint32_t WatchpointPacket::type() const {
  // @@protoc_insertion_point(field_get:WatchpointPacket.Type)
  return _internal_type();
}
inline void WatchpointPacket::_internal_set_type(uint32_t value) {
  
  type_ = value;
}
inline void WatchpointPacket::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:WatchpointPacket.Type)
}

// uint32 Length = 5;
inline void WatchpointPacket::clear_length() {
  length_ = 0u;
}
inline uint32_t WatchpointPacket::_internal_length() const {
  return length_;
}
inline uint32_t WatchpointPacket::length() const {
  // @@protoc_insertion_point(field_get:WatchpointPacket.Length)
  return _internal_length();
}
inline void WatchpointPacket::_internal_set_length(uint32_t value) {
  
  length_ = value;
}
inline void WatchpointPacket::set_length(uint32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:WatchpointPacket.Length)
}

// -------------------------------------------------------------------

// WatchpointListPacket

// repeated .WatchpointPacket Watchpoints = 1;
inline int WatchpointListPacket::_internal_watchpoints_size() const {
  return watchpoints_.size();
}
inline int WatchpointListPacket::watchpoints_size() const {
  return _internal_watchpoints_size();
}
inline void WatchpointListPacket::clear_watchpoints() {
  watchpoints_.Clear();
}
inline ::WatchpointPacket* WatchpointListPacket::mutable_watchpoints(int index) {
  // @@protoc_insertion_point(field_mutable:WatchpointListPacket.Watchpoints)
  return watchpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WatchpointPacket >*
WatchpointListPacket::mutable_watchpoints() {
  // @@protoc_insertion_point(field_mutable_list:WatchpointListPacket.Watchpoints)
  return &watchpoints_;
}
inline const ::WatchpointPacket& WatchpointListPacket::_internal_watchpoints(int index) const {
  return watchpoints_.Get(index);
}
inline const ::WatchpointPacket& WatchpointListPacket::watchpoints(int index) const {
  // @@protoc_insertion_point(field_get:WatchpointListPacket.Watchpoints)
  return _internal_watchpoints(index);
}
inline ::WatchpointPacket* WatchpointListPacket::_internal_add_watchpoints() {
  return watchpoints_.Add();
}
inline ::WatchpointPacket* WatchpointListPacket::add_watchpoints() {
  ::WatchpointPacket* _add = _internal_add_watchpoints();
  // @@protoc_insertion_point(field_add:WatchpointListPacket.Watchpoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WatchpointPacket >&
WatchpointListPacket::watchpoints() const {
  // @@protoc_insertion_point(field_list:WatchpointListPacket.Watchpoints)
  return watchpoints_;
}

// -------------------------------------------------------------------

// BreakpointPacket

// uint32 Index = 1;
inline void BreakpointPacket::clear_index() {
  index_ = 0u;
}
inline uint32_t BreakpointPacket::_internal_index() const {
  return index_;
}
inline uint32_t BreakpointPacket::index() const {
  // @@protoc_insertion_point(field_get:BreakpointPacket.Index)
  return _internal_index();
}
inline void BreakpointPacket::_internal_set_index(uint32_t value) {
  
  index_ = value;
}
inline void BreakpointPacket::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:BreakpointPacket.Index)
}

// bool Enabled = 2;
inline void BreakpointPacket::clear_enabled() {
  enabled_ = false;
}
inline bool BreakpointPacket::_internal_enabled() const {
  return enabled_;
}
inline bool BreakpointPacket::enabled() const {
  // @@protoc_insertion_point(field_get:BreakpointPacket.Enabled)
  return _internal_enabled();
}
inline void BreakpointPacket::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void BreakpointPacket::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:BreakpointPacket.Enabled)
}

// uint64 Address = 3;
inline void BreakpointPacket::clear_address() {
  address_ = uint64_t{0u};
}
inline uint64_t BreakpointPacket::_internal_address() const {
  return address_;
}
inline uint64_t BreakpointPacket::address() const {
  // @@protoc_insertion_point(field_get:BreakpointPacket.Address)
  return _internal_address();
}
inline void BreakpointPacket::_internal_set_address(uint64_t value) {
  
  address_ = value;
}
inline void BreakpointPacket::set_address(uint64_t value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:BreakpointPacket.Address)
}

// -------------------------------------------------------------------

// BreakpointListPacket

// repeated .BreakpointPacket Breakpoints = 1;
inline int BreakpointListPacket::_internal_breakpoints_size() const {
  return breakpoints_.size();
}
inline int BreakpointListPacket::breakpoints_size() const {
  return _internal_breakpoints_size();
}
inline void BreakpointListPacket::clear_breakpoints() {
  breakpoints_.Clear();
}
inline ::BreakpointPacket* BreakpointListPacket::mutable_breakpoints(int index) {
  // @@protoc_insertion_point(field_mutable:BreakpointListPacket.Breakpoints)
  return breakpoints_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BreakpointPacket >*
BreakpointListPacket::mutable_breakpoints() {
  // @@protoc_insertion_point(field_mutable_list:BreakpointListPacket.Breakpoints)
  return &breakpoints_;
}
inline const ::BreakpointPacket& BreakpointListPacket::_internal_breakpoints(int index) const {
  return breakpoints_.Get(index);
}
inline const ::BreakpointPacket& BreakpointListPacket::breakpoints(int index) const {
  // @@protoc_insertion_point(field_get:BreakpointListPacket.Breakpoints)
  return _internal_breakpoints(index);
}
inline ::BreakpointPacket* BreakpointListPacket::_internal_add_breakpoints() {
  return breakpoints_.Add();
}
inline ::BreakpointPacket* BreakpointListPacket::add_breakpoints() {
  ::BreakpointPacket* _add = _internal_add_breakpoints();
  // @@protoc_insertion_point(field_add:BreakpointListPacket.Breakpoints)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::BreakpointPacket >&
BreakpointListPacket::breakpoints() const {
  // @@protoc_insertion_point(field_list:BreakpointListPacket.Breakpoints)
  return breakpoints_;
}

// -------------------------------------------------------------------

// SetProcessProtPacket

// uint64 Address = 1;
inline void SetProcessProtPacket::clear_address() {
  address_ = uint64_t{0u};
}
inline uint64_t SetProcessProtPacket::_internal_address() const {
  return address_;
}
inline uint64_t SetProcessProtPacket::address() const {
  // @@protoc_insertion_point(field_get:SetProcessProtPacket.Address)
  return _internal_address();
}
inline void SetProcessProtPacket::_internal_set_address(uint64_t value) {
  
  address_ = value;
}
inline void SetProcessProtPacket::set_address(uint64_t value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:SetProcessProtPacket.Address)
}

// uint64 Size = 2;
inline void SetProcessProtPacket::clear_size() {
  size_ = uint64_t{0u};
}
inline uint64_t SetProcessProtPacket::_internal_size() const {
  return size_;
}
inline uint64_t SetProcessProtPacket::size() const {
  // @@protoc_insertion_point(field_get:SetProcessProtPacket.Size)
  return _internal_size();
}
inline void SetProcessProtPacket::_internal_set_size(uint64_t value) {
  
  size_ = value;
}
inline void SetProcessProtPacket::set_size(uint64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:SetProcessProtPacket.Size)
}

// int32 Prot = 3;
inline void SetProcessProtPacket::clear_prot() {
  prot_ = 0;
}
inline int32_t SetProcessProtPacket::_internal_prot() const {
  return prot_;
}
inline int32_t SetProcessProtPacket::prot() const {
  // @@protoc_insertion_point(field_get:SetProcessProtPacket.Prot)
  return _internal_prot();
}
inline void SetProcessProtPacket::_internal_set_prot(int32_t value) {
  
  prot_ = value;
}
inline void SetProcessProtPacket::set_prot(int32_t value) {
  _internal_set_prot(value);
  // @@protoc_insertion_point(field_set:SetProcessProtPacket.Prot)
}

// -------------------------------------------------------------------

// Envxmm

// uint32 en_cw = 1;
inline void Envxmm::clear_en_cw() {
  en_cw_ = 0u;
}
inline uint32_t Envxmm::_internal_en_cw() const {
  return en_cw_;
}
inline uint32_t Envxmm::en_cw() const {
  // @@protoc_insertion_point(field_get:Envxmm.en_cw)
  return _internal_en_cw();
}
inline void Envxmm::_internal_set_en_cw(uint32_t value) {
  
  en_cw_ = value;
}
inline void Envxmm::set_en_cw(uint32_t value) {
  _internal_set_en_cw(value);
  // @@protoc_insertion_point(field_set:Envxmm.en_cw)
}

// uint32 en_sw = 2;
inline void Envxmm::clear_en_sw() {
  en_sw_ = 0u;
}
inline uint32_t Envxmm::_internal_en_sw() const {
  return en_sw_;
}
inline uint32_t Envxmm::en_sw() const {
  // @@protoc_insertion_point(field_get:Envxmm.en_sw)
  return _internal_en_sw();
}
inline void Envxmm::_internal_set_en_sw(uint32_t value) {
  
  en_sw_ = value;
}
inline void Envxmm::set_en_sw(uint32_t value) {
  _internal_set_en_sw(value);
  // @@protoc_insertion_point(field_set:Envxmm.en_sw)
}

// uint32 en_tw = 3;
inline void Envxmm::clear_en_tw() {
  en_tw_ = 0u;
}
inline uint32_t Envxmm::_internal_en_tw() const {
  return en_tw_;
}
inline uint32_t Envxmm::en_tw() const {
  // @@protoc_insertion_point(field_get:Envxmm.en_tw)
  return _internal_en_tw();
}
inline void Envxmm::_internal_set_en_tw(uint32_t value) {
  
  en_tw_ = value;
}
inline void Envxmm::set_en_tw(uint32_t value) {
  _internal_set_en_tw(value);
  // @@protoc_insertion_point(field_set:Envxmm.en_tw)
}

// uint32 en_zero = 4;
inline void Envxmm::clear_en_zero() {
  en_zero_ = 0u;
}
inline uint32_t Envxmm::_internal_en_zero() const {
  return en_zero_;
}
inline uint32_t Envxmm::en_zero() const {
  // @@protoc_insertion_point(field_get:Envxmm.en_zero)
  return _internal_en_zero();
}
inline void Envxmm::_internal_set_en_zero(uint32_t value) {
  
  en_zero_ = value;
}
inline void Envxmm::set_en_zero(uint32_t value) {
  _internal_set_en_zero(value);
  // @@protoc_insertion_point(field_set:Envxmm.en_zero)
}

// uint32 en_opcode = 5;
inline void Envxmm::clear_en_opcode() {
  en_opcode_ = 0u;
}
inline uint32_t Envxmm::_internal_en_opcode() const {
  return en_opcode_;
}
inline uint32_t Envxmm::en_opcode() const {
  // @@protoc_insertion_point(field_get:Envxmm.en_opcode)
  return _internal_en_opcode();
}
inline void Envxmm::_internal_set_en_opcode(uint32_t value) {
  
  en_opcode_ = value;
}
inline void Envxmm::set_en_opcode(uint32_t value) {
  _internal_set_en_opcode(value);
  // @@protoc_insertion_point(field_set:Envxmm.en_opcode)
}

// uint64 en_rip = 6;
inline void Envxmm::clear_en_rip() {
  en_rip_ = uint64_t{0u};
}
inline uint64_t Envxmm::_internal_en_rip() const {
  return en_rip_;
}
inline uint64_t Envxmm::en_rip() const {
  // @@protoc_insertion_point(field_get:Envxmm.en_rip)
  return _internal_en_rip();
}
inline void Envxmm::_internal_set_en_rip(uint64_t value) {
  
  en_rip_ = value;
}
inline void Envxmm::set_en_rip(uint64_t value) {
  _internal_set_en_rip(value);
  // @@protoc_insertion_point(field_set:Envxmm.en_rip)
}

// uint64 en_rdp = 7;
inline void Envxmm::clear_en_rdp() {
  en_rdp_ = uint64_t{0u};
}
inline uint64_t Envxmm::_internal_en_rdp() const {
  return en_rdp_;
}
inline uint64_t Envxmm::en_rdp() const {
  // @@protoc_insertion_point(field_get:Envxmm.en_rdp)
  return _internal_en_rdp();
}
inline void Envxmm::_internal_set_en_rdp(uint64_t value) {
  
  en_rdp_ = value;
}
inline void Envxmm::set_en_rdp(uint64_t value) {
  _internal_set_en_rdp(value);
  // @@protoc_insertion_point(field_set:Envxmm.en_rdp)
}

// uint32 en_mxcsr = 8;
inline void Envxmm::clear_en_mxcsr() {
  en_mxcsr_ = 0u;
}
inline uint32_t Envxmm::_internal_en_mxcsr() const {
  return en_mxcsr_;
}
inline uint32_t Envxmm::en_mxcsr() const {
  // @@protoc_insertion_point(field_get:Envxmm.en_mxcsr)
  return _internal_en_mxcsr();
}
inline void Envxmm::_internal_set_en_mxcsr(uint32_t value) {
  
  en_mxcsr_ = value;
}
inline void Envxmm::set_en_mxcsr(uint32_t value) {
  _internal_set_en_mxcsr(value);
  // @@protoc_insertion_point(field_set:Envxmm.en_mxcsr)
}

// uint32 en_mxcsr_mask = 9;
inline void Envxmm::clear_en_mxcsr_mask() {
  en_mxcsr_mask_ = 0u;
}
inline uint32_t Envxmm::_internal_en_mxcsr_mask() const {
  return en_mxcsr_mask_;
}
inline uint32_t Envxmm::en_mxcsr_mask() const {
  // @@protoc_insertion_point(field_get:Envxmm.en_mxcsr_mask)
  return _internal_en_mxcsr_mask();
}
inline void Envxmm::_internal_set_en_mxcsr_mask(uint32_t value) {
  
  en_mxcsr_mask_ = value;
}
inline void Envxmm::set_en_mxcsr_mask(uint32_t value) {
  _internal_set_en_mxcsr_mask(value);
  // @@protoc_insertion_point(field_set:Envxmm.en_mxcsr_mask)
}

// -------------------------------------------------------------------

// Acc

// bytes fp_bytes = 1;
inline void Acc::clear_fp_bytes() {
  fp_bytes_.ClearToEmpty();
}
inline const std::string& Acc::fp_bytes() const {
  // @@protoc_insertion_point(field_get:Acc.fp_bytes)
  return _internal_fp_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Acc::set_fp_bytes(ArgT0&& arg0, ArgT... args) {
 
 fp_bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Acc.fp_bytes)
}
inline std::string* Acc::mutable_fp_bytes() {
  std::string* _s = _internal_mutable_fp_bytes();
  // @@protoc_insertion_point(field_mutable:Acc.fp_bytes)
  return _s;
}
inline const std::string& Acc::_internal_fp_bytes() const {
  return fp_bytes_.Get();
}
inline void Acc::_internal_set_fp_bytes(const std::string& value) {
  
  fp_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Acc::_internal_mutable_fp_bytes() {
  
  return fp_bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Acc::release_fp_bytes() {
  // @@protoc_insertion_point(field_release:Acc.fp_bytes)
  return fp_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Acc::set_allocated_fp_bytes(std::string* fp_bytes) {
  if (fp_bytes != nullptr) {
    
  } else {
    
  }
  fp_bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fp_bytes,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fp_bytes_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fp_bytes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Acc.fp_bytes)
}

// -------------------------------------------------------------------

// Xmmacc

// bytes xmm_bytes = 1;
inline void Xmmacc::clear_xmm_bytes() {
  xmm_bytes_.ClearToEmpty();
}
inline const std::string& Xmmacc::xmm_bytes() const {
  // @@protoc_insertion_point(field_get:Xmmacc.xmm_bytes)
  return _internal_xmm_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Xmmacc::set_xmm_bytes(ArgT0&& arg0, ArgT... args) {
 
 xmm_bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Xmmacc.xmm_bytes)
}
inline std::string* Xmmacc::mutable_xmm_bytes() {
  std::string* _s = _internal_mutable_xmm_bytes();
  // @@protoc_insertion_point(field_mutable:Xmmacc.xmm_bytes)
  return _s;
}
inline const std::string& Xmmacc::_internal_xmm_bytes() const {
  return xmm_bytes_.Get();
}
inline void Xmmacc::_internal_set_xmm_bytes(const std::string& value) {
  
  xmm_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Xmmacc::_internal_mutable_xmm_bytes() {
  
  return xmm_bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Xmmacc::release_xmm_bytes() {
  // @@protoc_insertion_point(field_release:Xmmacc.xmm_bytes)
  return xmm_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Xmmacc::set_allocated_xmm_bytes(std::string* xmm_bytes) {
  if (xmm_bytes != nullptr) {
    
  } else {
    
  }
  xmm_bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), xmm_bytes,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (xmm_bytes_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    xmm_bytes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Xmmacc.xmm_bytes)
}

// -------------------------------------------------------------------

// Ymmacc

// bytes ymm_bytes = 1;
inline void Ymmacc::clear_ymm_bytes() {
  ymm_bytes_.ClearToEmpty();
}
inline const std::string& Ymmacc::ymm_bytes() const {
  // @@protoc_insertion_point(field_get:Ymmacc.ymm_bytes)
  return _internal_ymm_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ymmacc::set_ymm_bytes(ArgT0&& arg0, ArgT... args) {
 
 ymm_bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Ymmacc.ymm_bytes)
}
inline std::string* Ymmacc::mutable_ymm_bytes() {
  std::string* _s = _internal_mutable_ymm_bytes();
  // @@protoc_insertion_point(field_mutable:Ymmacc.ymm_bytes)
  return _s;
}
inline const std::string& Ymmacc::_internal_ymm_bytes() const {
  return ymm_bytes_.Get();
}
inline void Ymmacc::_internal_set_ymm_bytes(const std::string& value) {
  
  ymm_bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Ymmacc::_internal_mutable_ymm_bytes() {
  
  return ymm_bytes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Ymmacc::release_ymm_bytes() {
  // @@protoc_insertion_point(field_release:Ymmacc.ymm_bytes)
  return ymm_bytes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Ymmacc::set_allocated_ymm_bytes(std::string* ymm_bytes) {
  if (ymm_bytes != nullptr) {
    
  } else {
    
  }
  ymm_bytes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ymm_bytes,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ymm_bytes_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ymm_bytes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Ymmacc.ymm_bytes)
}

// -------------------------------------------------------------------

// XstateHdr

// uint64 xstate_bv = 1;
inline void XstateHdr::clear_xstate_bv() {
  xstate_bv_ = uint64_t{0u};
}
inline uint64_t XstateHdr::_internal_xstate_bv() const {
  return xstate_bv_;
}
inline uint64_t XstateHdr::xstate_bv() const {
  // @@protoc_insertion_point(field_get:XstateHdr.xstate_bv)
  return _internal_xstate_bv();
}
inline void XstateHdr::_internal_set_xstate_bv(uint64_t value) {
  
  xstate_bv_ = value;
}
inline void XstateHdr::set_xstate_bv(uint64_t value) {
  _internal_set_xstate_bv(value);
  // @@protoc_insertion_point(field_set:XstateHdr.xstate_bv)
}

// -------------------------------------------------------------------

// SavefpuXstate

// .XstateHdr sx_hd = 1;
inline bool SavefpuXstate::_internal_has_sx_hd() const {
  return this != internal_default_instance() && sx_hd_ != nullptr;
}
inline bool SavefpuXstate::has_sx_hd() const {
  return _internal_has_sx_hd();
}
inline void SavefpuXstate::clear_sx_hd() {
  if (GetArenaForAllocation() == nullptr && sx_hd_ != nullptr) {
    delete sx_hd_;
  }
  sx_hd_ = nullptr;
}
inline const ::XstateHdr& SavefpuXstate::_internal_sx_hd() const {
  const ::XstateHdr* p = sx_hd_;
  return p != nullptr ? *p : reinterpret_cast<const ::XstateHdr&>(
      ::_XstateHdr_default_instance_);
}
inline const ::XstateHdr& SavefpuXstate::sx_hd() const {
  // @@protoc_insertion_point(field_get:SavefpuXstate.sx_hd)
  return _internal_sx_hd();
}
inline void SavefpuXstate::unsafe_arena_set_allocated_sx_hd(
    ::XstateHdr* sx_hd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sx_hd_);
  }
  sx_hd_ = sx_hd;
  if (sx_hd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SavefpuXstate.sx_hd)
}
inline ::XstateHdr* SavefpuXstate::release_sx_hd() {
  
  ::XstateHdr* temp = sx_hd_;
  sx_hd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::XstateHdr* SavefpuXstate::unsafe_arena_release_sx_hd() {
  // @@protoc_insertion_point(field_release:SavefpuXstate.sx_hd)
  
  ::XstateHdr* temp = sx_hd_;
  sx_hd_ = nullptr;
  return temp;
}
inline ::XstateHdr* SavefpuXstate::_internal_mutable_sx_hd() {
  
  if (sx_hd_ == nullptr) {
    auto* p = CreateMaybeMessage<::XstateHdr>(GetArenaForAllocation());
    sx_hd_ = p;
  }
  return sx_hd_;
}
inline ::XstateHdr* SavefpuXstate::mutable_sx_hd() {
  ::XstateHdr* _msg = _internal_mutable_sx_hd();
  // @@protoc_insertion_point(field_mutable:SavefpuXstate.sx_hd)
  return _msg;
}
inline void SavefpuXstate::set_allocated_sx_hd(::XstateHdr* sx_hd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sx_hd_;
  }
  if (sx_hd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::XstateHdr>::GetOwningArena(sx_hd);
    if (message_arena != submessage_arena) {
      sx_hd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sx_hd, submessage_arena);
    }
    
  } else {
    
  }
  sx_hd_ = sx_hd;
  // @@protoc_insertion_point(field_set_allocated:SavefpuXstate.sx_hd)
}

// repeated .Ymmacc sx_ymm = 2;
inline int SavefpuXstate::_internal_sx_ymm_size() const {
  return sx_ymm_.size();
}
inline int SavefpuXstate::sx_ymm_size() const {
  return _internal_sx_ymm_size();
}
inline void SavefpuXstate::clear_sx_ymm() {
  sx_ymm_.Clear();
}
inline ::Ymmacc* SavefpuXstate::mutable_sx_ymm(int index) {
  // @@protoc_insertion_point(field_mutable:SavefpuXstate.sx_ymm)
  return sx_ymm_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Ymmacc >*
SavefpuXstate::mutable_sx_ymm() {
  // @@protoc_insertion_point(field_mutable_list:SavefpuXstate.sx_ymm)
  return &sx_ymm_;
}
inline const ::Ymmacc& SavefpuXstate::_internal_sx_ymm(int index) const {
  return sx_ymm_.Get(index);
}
inline const ::Ymmacc& SavefpuXstate::sx_ymm(int index) const {
  // @@protoc_insertion_point(field_get:SavefpuXstate.sx_ymm)
  return _internal_sx_ymm(index);
}
inline ::Ymmacc* SavefpuXstate::_internal_add_sx_ymm() {
  return sx_ymm_.Add();
}
inline ::Ymmacc* SavefpuXstate::add_sx_ymm() {
  ::Ymmacc* _add = _internal_add_sx_ymm();
  // @@protoc_insertion_point(field_add:SavefpuXstate.sx_ymm)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Ymmacc >&
SavefpuXstate::sx_ymm() const {
  // @@protoc_insertion_point(field_list:SavefpuXstate.sx_ymm)
  return sx_ymm_;
}

// -------------------------------------------------------------------

// Fpregs

// .Envxmm svn_env = 1;
inline bool Fpregs::_internal_has_svn_env() const {
  return this != internal_default_instance() && svn_env_ != nullptr;
}
inline bool Fpregs::has_svn_env() const {
  return _internal_has_svn_env();
}
inline void Fpregs::clear_svn_env() {
  if (GetArenaForAllocation() == nullptr && svn_env_ != nullptr) {
    delete svn_env_;
  }
  svn_env_ = nullptr;
}
inline const ::Envxmm& Fpregs::_internal_svn_env() const {
  const ::Envxmm* p = svn_env_;
  return p != nullptr ? *p : reinterpret_cast<const ::Envxmm&>(
      ::_Envxmm_default_instance_);
}
inline const ::Envxmm& Fpregs::svn_env() const {
  // @@protoc_insertion_point(field_get:Fpregs.svn_env)
  return _internal_svn_env();
}
inline void Fpregs::unsafe_arena_set_allocated_svn_env(
    ::Envxmm* svn_env) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(svn_env_);
  }
  svn_env_ = svn_env;
  if (svn_env) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Fpregs.svn_env)
}
inline ::Envxmm* Fpregs::release_svn_env() {
  
  ::Envxmm* temp = svn_env_;
  svn_env_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Envxmm* Fpregs::unsafe_arena_release_svn_env() {
  // @@protoc_insertion_point(field_release:Fpregs.svn_env)
  
  ::Envxmm* temp = svn_env_;
  svn_env_ = nullptr;
  return temp;
}
inline ::Envxmm* Fpregs::_internal_mutable_svn_env() {
  
  if (svn_env_ == nullptr) {
    auto* p = CreateMaybeMessage<::Envxmm>(GetArenaForAllocation());
    svn_env_ = p;
  }
  return svn_env_;
}
inline ::Envxmm* Fpregs::mutable_svn_env() {
  ::Envxmm* _msg = _internal_mutable_svn_env();
  // @@protoc_insertion_point(field_mutable:Fpregs.svn_env)
  return _msg;
}
inline void Fpregs::set_allocated_svn_env(::Envxmm* svn_env) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete svn_env_;
  }
  if (svn_env) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Envxmm>::GetOwningArena(svn_env);
    if (message_arena != submessage_arena) {
      svn_env = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, svn_env, submessage_arena);
    }
    
  } else {
    
  }
  svn_env_ = svn_env;
  // @@protoc_insertion_point(field_set_allocated:Fpregs.svn_env)
}

// repeated .Acc sv_fp = 2;
inline int Fpregs::_internal_sv_fp_size() const {
  return sv_fp_.size();
}
inline int Fpregs::sv_fp_size() const {
  return _internal_sv_fp_size();
}
inline void Fpregs::clear_sv_fp() {
  sv_fp_.Clear();
}
inline ::Acc* Fpregs::mutable_sv_fp(int index) {
  // @@protoc_insertion_point(field_mutable:Fpregs.sv_fp)
  return sv_fp_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Acc >*
Fpregs::mutable_sv_fp() {
  // @@protoc_insertion_point(field_mutable_list:Fpregs.sv_fp)
  return &sv_fp_;
}
inline const ::Acc& Fpregs::_internal_sv_fp(int index) const {
  return sv_fp_.Get(index);
}
inline const ::Acc& Fpregs::sv_fp(int index) const {
  // @@protoc_insertion_point(field_get:Fpregs.sv_fp)
  return _internal_sv_fp(index);
}
inline ::Acc* Fpregs::_internal_add_sv_fp() {
  return sv_fp_.Add();
}
inline ::Acc* Fpregs::add_sv_fp() {
  ::Acc* _add = _internal_add_sv_fp();
  // @@protoc_insertion_point(field_add:Fpregs.sv_fp)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Acc >&
Fpregs::sv_fp() const {
  // @@protoc_insertion_point(field_list:Fpregs.sv_fp)
  return sv_fp_;
}

// repeated .Xmmacc sv_xmm = 3;
inline int Fpregs::_internal_sv_xmm_size() const {
  return sv_xmm_.size();
}
inline int Fpregs::sv_xmm_size() const {
  return _internal_sv_xmm_size();
}
inline void Fpregs::clear_sv_xmm() {
  sv_xmm_.Clear();
}
inline ::Xmmacc* Fpregs::mutable_sv_xmm(int index) {
  // @@protoc_insertion_point(field_mutable:Fpregs.sv_xmm)
  return sv_xmm_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Xmmacc >*
Fpregs::mutable_sv_xmm() {
  // @@protoc_insertion_point(field_mutable_list:Fpregs.sv_xmm)
  return &sv_xmm_;
}
inline const ::Xmmacc& Fpregs::_internal_sv_xmm(int index) const {
  return sv_xmm_.Get(index);
}
inline const ::Xmmacc& Fpregs::sv_xmm(int index) const {
  // @@protoc_insertion_point(field_get:Fpregs.sv_xmm)
  return _internal_sv_xmm(index);
}
inline ::Xmmacc* Fpregs::_internal_add_sv_xmm() {
  return sv_xmm_.Add();
}
inline ::Xmmacc* Fpregs::add_sv_xmm() {
  ::Xmmacc* _add = _internal_add_sv_xmm();
  // @@protoc_insertion_point(field_add:Fpregs.sv_xmm)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Xmmacc >&
Fpregs::sv_xmm() const {
  // @@protoc_insertion_point(field_list:Fpregs.sv_xmm)
  return sv_xmm_;
}

// .SavefpuXstate sv_xstate = 5;
inline bool Fpregs::_internal_has_sv_xstate() const {
  return this != internal_default_instance() && sv_xstate_ != nullptr;
}
inline bool Fpregs::has_sv_xstate() const {
  return _internal_has_sv_xstate();
}
inline void Fpregs::clear_sv_xstate() {
  if (GetArenaForAllocation() == nullptr && sv_xstate_ != nullptr) {
    delete sv_xstate_;
  }
  sv_xstate_ = nullptr;
}
inline const ::SavefpuXstate& Fpregs::_internal_sv_xstate() const {
  const ::SavefpuXstate* p = sv_xstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::SavefpuXstate&>(
      ::_SavefpuXstate_default_instance_);
}
inline const ::SavefpuXstate& Fpregs::sv_xstate() const {
  // @@protoc_insertion_point(field_get:Fpregs.sv_xstate)
  return _internal_sv_xstate();
}
inline void Fpregs::unsafe_arena_set_allocated_sv_xstate(
    ::SavefpuXstate* sv_xstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sv_xstate_);
  }
  sv_xstate_ = sv_xstate;
  if (sv_xstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Fpregs.sv_xstate)
}
inline ::SavefpuXstate* Fpregs::release_sv_xstate() {
  
  ::SavefpuXstate* temp = sv_xstate_;
  sv_xstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::SavefpuXstate* Fpregs::unsafe_arena_release_sv_xstate() {
  // @@protoc_insertion_point(field_release:Fpregs.sv_xstate)
  
  ::SavefpuXstate* temp = sv_xstate_;
  sv_xstate_ = nullptr;
  return temp;
}
inline ::SavefpuXstate* Fpregs::_internal_mutable_sv_xstate() {
  
  if (sv_xstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::SavefpuXstate>(GetArenaForAllocation());
    sv_xstate_ = p;
  }
  return sv_xstate_;
}
inline ::SavefpuXstate* Fpregs::mutable_sv_xstate() {
  ::SavefpuXstate* _msg = _internal_mutable_sv_xstate();
  // @@protoc_insertion_point(field_mutable:Fpregs.sv_xstate)
  return _msg;
}
inline void Fpregs::set_allocated_sv_xstate(::SavefpuXstate* sv_xstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sv_xstate_;
  }
  if (sv_xstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::SavefpuXstate>::GetOwningArena(sv_xstate);
    if (message_arena != submessage_arena) {
      sv_xstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sv_xstate, submessage_arena);
    }
    
  } else {
    
  }
  sv_xstate_ = sv_xstate;
  // @@protoc_insertion_point(field_set_allocated:Fpregs.sv_xstate)
}

// -------------------------------------------------------------------

// RegistersPacket

// uint64 r15 = 1;
inline void RegistersPacket::clear_r15() {
  r15_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_r15() const {
  return r15_;
}
inline uint64_t RegistersPacket::r15() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.r15)
  return _internal_r15();
}
inline void RegistersPacket::_internal_set_r15(uint64_t value) {
  
  r15_ = value;
}
inline void RegistersPacket::set_r15(uint64_t value) {
  _internal_set_r15(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.r15)
}

// uint64 r14 = 2;
inline void RegistersPacket::clear_r14() {
  r14_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_r14() const {
  return r14_;
}
inline uint64_t RegistersPacket::r14() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.r14)
  return _internal_r14();
}
inline void RegistersPacket::_internal_set_r14(uint64_t value) {
  
  r14_ = value;
}
inline void RegistersPacket::set_r14(uint64_t value) {
  _internal_set_r14(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.r14)
}

// uint64 r13 = 3;
inline void RegistersPacket::clear_r13() {
  r13_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_r13() const {
  return r13_;
}
inline uint64_t RegistersPacket::r13() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.r13)
  return _internal_r13();
}
inline void RegistersPacket::_internal_set_r13(uint64_t value) {
  
  r13_ = value;
}
inline void RegistersPacket::set_r13(uint64_t value) {
  _internal_set_r13(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.r13)
}

// uint64 r12 = 4;
inline void RegistersPacket::clear_r12() {
  r12_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_r12() const {
  return r12_;
}
inline uint64_t RegistersPacket::r12() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.r12)
  return _internal_r12();
}
inline void RegistersPacket::_internal_set_r12(uint64_t value) {
  
  r12_ = value;
}
inline void RegistersPacket::set_r12(uint64_t value) {
  _internal_set_r12(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.r12)
}

// uint64 r11 = 5;
inline void RegistersPacket::clear_r11() {
  r11_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_r11() const {
  return r11_;
}
inline uint64_t RegistersPacket::r11() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.r11)
  return _internal_r11();
}
inline void RegistersPacket::_internal_set_r11(uint64_t value) {
  
  r11_ = value;
}
inline void RegistersPacket::set_r11(uint64_t value) {
  _internal_set_r11(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.r11)
}

// uint64 r10 = 6;
inline void RegistersPacket::clear_r10() {
  r10_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_r10() const {
  return r10_;
}
inline uint64_t RegistersPacket::r10() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.r10)
  return _internal_r10();
}
inline void RegistersPacket::_internal_set_r10(uint64_t value) {
  
  r10_ = value;
}
inline void RegistersPacket::set_r10(uint64_t value) {
  _internal_set_r10(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.r10)
}

// uint64 r9 = 7;
inline void RegistersPacket::clear_r9() {
  r9_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_r9() const {
  return r9_;
}
inline uint64_t RegistersPacket::r9() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.r9)
  return _internal_r9();
}
inline void RegistersPacket::_internal_set_r9(uint64_t value) {
  
  r9_ = value;
}
inline void RegistersPacket::set_r9(uint64_t value) {
  _internal_set_r9(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.r9)
}

// uint64 r8 = 8;
inline void RegistersPacket::clear_r8() {
  r8_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_r8() const {
  return r8_;
}
inline uint64_t RegistersPacket::r8() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.r8)
  return _internal_r8();
}
inline void RegistersPacket::_internal_set_r8(uint64_t value) {
  
  r8_ = value;
}
inline void RegistersPacket::set_r8(uint64_t value) {
  _internal_set_r8(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.r8)
}

// uint64 rdi = 9;
inline void RegistersPacket::clear_rdi() {
  rdi_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_rdi() const {
  return rdi_;
}
inline uint64_t RegistersPacket::rdi() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.rdi)
  return _internal_rdi();
}
inline void RegistersPacket::_internal_set_rdi(uint64_t value) {
  
  rdi_ = value;
}
inline void RegistersPacket::set_rdi(uint64_t value) {
  _internal_set_rdi(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.rdi)
}

// uint64 rsi = 10;
inline void RegistersPacket::clear_rsi() {
  rsi_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_rsi() const {
  return rsi_;
}
inline uint64_t RegistersPacket::rsi() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.rsi)
  return _internal_rsi();
}
inline void RegistersPacket::_internal_set_rsi(uint64_t value) {
  
  rsi_ = value;
}
inline void RegistersPacket::set_rsi(uint64_t value) {
  _internal_set_rsi(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.rsi)
}

// uint64 rbp = 11;
inline void RegistersPacket::clear_rbp() {
  rbp_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_rbp() const {
  return rbp_;
}
inline uint64_t RegistersPacket::rbp() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.rbp)
  return _internal_rbp();
}
inline void RegistersPacket::_internal_set_rbp(uint64_t value) {
  
  rbp_ = value;
}
inline void RegistersPacket::set_rbp(uint64_t value) {
  _internal_set_rbp(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.rbp)
}

// uint64 rbx = 12;
inline void RegistersPacket::clear_rbx() {
  rbx_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_rbx() const {
  return rbx_;
}
inline uint64_t RegistersPacket::rbx() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.rbx)
  return _internal_rbx();
}
inline void RegistersPacket::_internal_set_rbx(uint64_t value) {
  
  rbx_ = value;
}
inline void RegistersPacket::set_rbx(uint64_t value) {
  _internal_set_rbx(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.rbx)
}

// uint64 rdx = 13;
inline void RegistersPacket::clear_rdx() {
  rdx_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_rdx() const {
  return rdx_;
}
inline uint64_t RegistersPacket::rdx() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.rdx)
  return _internal_rdx();
}
inline void RegistersPacket::_internal_set_rdx(uint64_t value) {
  
  rdx_ = value;
}
inline void RegistersPacket::set_rdx(uint64_t value) {
  _internal_set_rdx(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.rdx)
}

// uint64 rcx = 14;
inline void RegistersPacket::clear_rcx() {
  rcx_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_rcx() const {
  return rcx_;
}
inline uint64_t RegistersPacket::rcx() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.rcx)
  return _internal_rcx();
}
inline void RegistersPacket::_internal_set_rcx(uint64_t value) {
  
  rcx_ = value;
}
inline void RegistersPacket::set_rcx(uint64_t value) {
  _internal_set_rcx(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.rcx)
}

// uint64 rax = 15;
inline void RegistersPacket::clear_rax() {
  rax_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_rax() const {
  return rax_;
}
inline uint64_t RegistersPacket::rax() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.rax)
  return _internal_rax();
}
inline void RegistersPacket::_internal_set_rax(uint64_t value) {
  
  rax_ = value;
}
inline void RegistersPacket::set_rax(uint64_t value) {
  _internal_set_rax(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.rax)
}

// uint32 trapno = 16;
inline void RegistersPacket::clear_trapno() {
  trapno_ = 0u;
}
inline uint32_t RegistersPacket::_internal_trapno() const {
  return trapno_;
}
inline uint32_t RegistersPacket::trapno() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.trapno)
  return _internal_trapno();
}
inline void RegistersPacket::_internal_set_trapno(uint32_t value) {
  
  trapno_ = value;
}
inline void RegistersPacket::set_trapno(uint32_t value) {
  _internal_set_trapno(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.trapno)
}

// uint32 fs = 17;
inline void RegistersPacket::clear_fs() {
  fs_ = 0u;
}
inline uint32_t RegistersPacket::_internal_fs() const {
  return fs_;
}
inline uint32_t RegistersPacket::fs() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.fs)
  return _internal_fs();
}
inline void RegistersPacket::_internal_set_fs(uint32_t value) {
  
  fs_ = value;
}
inline void RegistersPacket::set_fs(uint32_t value) {
  _internal_set_fs(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.fs)
}

// uint32 gs = 18;
inline void RegistersPacket::clear_gs() {
  gs_ = 0u;
}
inline uint32_t RegistersPacket::_internal_gs() const {
  return gs_;
}
inline uint32_t RegistersPacket::gs() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.gs)
  return _internal_gs();
}
inline void RegistersPacket::_internal_set_gs(uint32_t value) {
  
  gs_ = value;
}
inline void RegistersPacket::set_gs(uint32_t value) {
  _internal_set_gs(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.gs)
}

// uint64 err = 19;
inline void RegistersPacket::clear_err() {
  err_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_err() const {
  return err_;
}
inline uint64_t RegistersPacket::err() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.err)
  return _internal_err();
}
inline void RegistersPacket::_internal_set_err(uint64_t value) {
  
  err_ = value;
}
inline void RegistersPacket::set_err(uint64_t value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.err)
}

// uint32 es = 20;
inline void RegistersPacket::clear_es() {
  es_ = 0u;
}
inline uint32_t RegistersPacket::_internal_es() const {
  return es_;
}
inline uint32_t RegistersPacket::es() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.es)
  return _internal_es();
}
inline void RegistersPacket::_internal_set_es(uint32_t value) {
  
  es_ = value;
}
inline void RegistersPacket::set_es(uint32_t value) {
  _internal_set_es(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.es)
}

// uint32 ds = 21;
inline void RegistersPacket::clear_ds() {
  ds_ = 0u;
}
inline uint32_t RegistersPacket::_internal_ds() const {
  return ds_;
}
inline uint32_t RegistersPacket::ds() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.ds)
  return _internal_ds();
}
inline void RegistersPacket::_internal_set_ds(uint32_t value) {
  
  ds_ = value;
}
inline void RegistersPacket::set_ds(uint32_t value) {
  _internal_set_ds(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.ds)
}

// uint64 rip = 22;
inline void RegistersPacket::clear_rip() {
  rip_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_rip() const {
  return rip_;
}
inline uint64_t RegistersPacket::rip() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.rip)
  return _internal_rip();
}
inline void RegistersPacket::_internal_set_rip(uint64_t value) {
  
  rip_ = value;
}
inline void RegistersPacket::set_rip(uint64_t value) {
  _internal_set_rip(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.rip)
}

// uint64 cs = 23;
inline void RegistersPacket::clear_cs() {
  cs_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_cs() const {
  return cs_;
}
inline uint64_t RegistersPacket::cs() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.cs)
  return _internal_cs();
}
inline void RegistersPacket::_internal_set_cs(uint64_t value) {
  
  cs_ = value;
}
inline void RegistersPacket::set_cs(uint64_t value) {
  _internal_set_cs(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.cs)
}

// uint64 rflags = 24;
inline void RegistersPacket::clear_rflags() {
  rflags_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_rflags() const {
  return rflags_;
}
inline uint64_t RegistersPacket::rflags() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.rflags)
  return _internal_rflags();
}
inline void RegistersPacket::_internal_set_rflags(uint64_t value) {
  
  rflags_ = value;
}
inline void RegistersPacket::set_rflags(uint64_t value) {
  _internal_set_rflags(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.rflags)
}

// uint64 rsp = 25;
inline void RegistersPacket::clear_rsp() {
  rsp_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_rsp() const {
  return rsp_;
}
inline uint64_t RegistersPacket::rsp() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.rsp)
  return _internal_rsp();
}
inline void RegistersPacket::_internal_set_rsp(uint64_t value) {
  
  rsp_ = value;
}
inline void RegistersPacket::set_rsp(uint64_t value) {
  _internal_set_rsp(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.rsp)
}

// uint64 ss = 26;
inline void RegistersPacket::clear_ss() {
  ss_ = uint64_t{0u};
}
inline uint64_t RegistersPacket::_internal_ss() const {
  return ss_;
}
inline uint64_t RegistersPacket::ss() const {
  // @@protoc_insertion_point(field_get:RegistersPacket.ss)
  return _internal_ss();
}
inline void RegistersPacket::_internal_set_ss(uint64_t value) {
  
  ss_ = value;
}
inline void RegistersPacket::set_ss(uint64_t value) {
  _internal_set_ss(value);
  // @@protoc_insertion_point(field_set:RegistersPacket.ss)
}

// -------------------------------------------------------------------

// DebuggerInterruptPacket

// uint32 ThreadId = 1;
inline void DebuggerInterruptPacket::clear_threadid() {
  threadid_ = 0u;
}
inline uint32_t DebuggerInterruptPacket::_internal_threadid() const {
  return threadid_;
}
inline uint32_t DebuggerInterruptPacket::threadid() const {
  // @@protoc_insertion_point(field_get:DebuggerInterruptPacket.ThreadId)
  return _internal_threadid();
}
inline void DebuggerInterruptPacket::_internal_set_threadid(uint32_t value) {
  
  threadid_ = value;
}
inline void DebuggerInterruptPacket::set_threadid(uint32_t value) {
  _internal_set_threadid(value);
  // @@protoc_insertion_point(field_set:DebuggerInterruptPacket.ThreadId)
}

// uint32 Status = 2;
inline void DebuggerInterruptPacket::clear_status() {
  status_ = 0u;
}
inline uint32_t DebuggerInterruptPacket::_internal_status() const {
  return status_;
}
inline uint32_t DebuggerInterruptPacket::status() const {
  // @@protoc_insertion_point(field_get:DebuggerInterruptPacket.Status)
  return _internal_status();
}
inline void DebuggerInterruptPacket::_internal_set_status(uint32_t value) {
  
  status_ = value;
}
inline void DebuggerInterruptPacket::set_status(uint32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:DebuggerInterruptPacket.Status)
}

// string Name = 3;
inline void DebuggerInterruptPacket::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DebuggerInterruptPacket::name() const {
  // @@protoc_insertion_point(field_get:DebuggerInterruptPacket.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DebuggerInterruptPacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DebuggerInterruptPacket.Name)
}
inline std::string* DebuggerInterruptPacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:DebuggerInterruptPacket.Name)
  return _s;
}
inline const std::string& DebuggerInterruptPacket::_internal_name() const {
  return name_.Get();
}
inline void DebuggerInterruptPacket::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DebuggerInterruptPacket::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DebuggerInterruptPacket::release_name() {
  // @@protoc_insertion_point(field_release:DebuggerInterruptPacket.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DebuggerInterruptPacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DebuggerInterruptPacket.Name)
}

// .RegistersPacket Registers = 4;
inline bool DebuggerInterruptPacket::_internal_has_registers() const {
  return this != internal_default_instance() && registers_ != nullptr;
}
inline bool DebuggerInterruptPacket::has_registers() const {
  return _internal_has_registers();
}
inline void DebuggerInterruptPacket::clear_registers() {
  if (GetArenaForAllocation() == nullptr && registers_ != nullptr) {
    delete registers_;
  }
  registers_ = nullptr;
}
inline const ::RegistersPacket& DebuggerInterruptPacket::_internal_registers() const {
  const ::RegistersPacket* p = registers_;
  return p != nullptr ? *p : reinterpret_cast<const ::RegistersPacket&>(
      ::_RegistersPacket_default_instance_);
}
inline const ::RegistersPacket& DebuggerInterruptPacket::registers() const {
  // @@protoc_insertion_point(field_get:DebuggerInterruptPacket.Registers)
  return _internal_registers();
}
inline void DebuggerInterruptPacket::unsafe_arena_set_allocated_registers(
    ::RegistersPacket* registers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(registers_);
  }
  registers_ = registers;
  if (registers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DebuggerInterruptPacket.Registers)
}
inline ::RegistersPacket* DebuggerInterruptPacket::release_registers() {
  
  ::RegistersPacket* temp = registers_;
  registers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::RegistersPacket* DebuggerInterruptPacket::unsafe_arena_release_registers() {
  // @@protoc_insertion_point(field_release:DebuggerInterruptPacket.Registers)
  
  ::RegistersPacket* temp = registers_;
  registers_ = nullptr;
  return temp;
}
inline ::RegistersPacket* DebuggerInterruptPacket::_internal_mutable_registers() {
  
  if (registers_ == nullptr) {
    auto* p = CreateMaybeMessage<::RegistersPacket>(GetArenaForAllocation());
    registers_ = p;
  }
  return registers_;
}
inline ::RegistersPacket* DebuggerInterruptPacket::mutable_registers() {
  ::RegistersPacket* _msg = _internal_mutable_registers();
  // @@protoc_insertion_point(field_mutable:DebuggerInterruptPacket.Registers)
  return _msg;
}
inline void DebuggerInterruptPacket::set_allocated_registers(::RegistersPacket* registers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete registers_;
  }
  if (registers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::RegistersPacket>::GetOwningArena(registers);
    if (message_arena != submessage_arena) {
      registers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, registers, submessage_arena);
    }
    
  } else {
    
  }
  registers_ = registers;
  // @@protoc_insertion_point(field_set_allocated:DebuggerInterruptPacket.Registers)
}

// .Fpregs FloatRegisters = 5;
inline bool DebuggerInterruptPacket::_internal_has_floatregisters() const {
  return this != internal_default_instance() && floatregisters_ != nullptr;
}
inline bool DebuggerInterruptPacket::has_floatregisters() const {
  return _internal_has_floatregisters();
}
inline void DebuggerInterruptPacket::clear_floatregisters() {
  if (GetArenaForAllocation() == nullptr && floatregisters_ != nullptr) {
    delete floatregisters_;
  }
  floatregisters_ = nullptr;
}
inline const ::Fpregs& DebuggerInterruptPacket::_internal_floatregisters() const {
  const ::Fpregs* p = floatregisters_;
  return p != nullptr ? *p : reinterpret_cast<const ::Fpregs&>(
      ::_Fpregs_default_instance_);
}
inline const ::Fpregs& DebuggerInterruptPacket::floatregisters() const {
  // @@protoc_insertion_point(field_get:DebuggerInterruptPacket.FloatRegisters)
  return _internal_floatregisters();
}
inline void DebuggerInterruptPacket::unsafe_arena_set_allocated_floatregisters(
    ::Fpregs* floatregisters) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(floatregisters_);
  }
  floatregisters_ = floatregisters;
  if (floatregisters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:DebuggerInterruptPacket.FloatRegisters)
}
inline ::Fpregs* DebuggerInterruptPacket::release_floatregisters() {
  
  ::Fpregs* temp = floatregisters_;
  floatregisters_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Fpregs* DebuggerInterruptPacket::unsafe_arena_release_floatregisters() {
  // @@protoc_insertion_point(field_release:DebuggerInterruptPacket.FloatRegisters)
  
  ::Fpregs* temp = floatregisters_;
  floatregisters_ = nullptr;
  return temp;
}
inline ::Fpregs* DebuggerInterruptPacket::_internal_mutable_floatregisters() {
  
  if (floatregisters_ == nullptr) {
    auto* p = CreateMaybeMessage<::Fpregs>(GetArenaForAllocation());
    floatregisters_ = p;
  }
  return floatregisters_;
}
inline ::Fpregs* DebuggerInterruptPacket::mutable_floatregisters() {
  ::Fpregs* _msg = _internal_mutable_floatregisters();
  // @@protoc_insertion_point(field_mutable:DebuggerInterruptPacket.FloatRegisters)
  return _msg;
}
inline void DebuggerInterruptPacket::set_allocated_floatregisters(::Fpregs* floatregisters) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete floatregisters_;
  }
  if (floatregisters) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Fpregs>::GetOwningArena(floatregisters);
    if (message_arena != submessage_arena) {
      floatregisters = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, floatregisters, submessage_arena);
    }
    
  } else {
    
  }
  floatregisters_ = floatregisters;
  // @@protoc_insertion_point(field_set_allocated:DebuggerInterruptPacket.FloatRegisters)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::APICommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::APICommand>() {
  return ::APICommand_descriptor();
}
template <> struct is_proto_enum< ::AppState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AppState>() {
  return ::AppState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_APIPackets_2eproto
